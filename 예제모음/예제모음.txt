21.11.29.1회차
===============================================================================
*단계별로 풀어보기 ~15552
===============================================================================






################################################################################################################
예제1)2588 곱셈

*정수의 자리수를 나타내는 api를 이용해야함

https://www.acmicpc.net/problem/2588
################################################################################################################



답:




package backjun;

import java.util.Scanner;

public class Main {
	private static final Scanner scan = new Scanner(System.in);
	
	public static void main(String[] args) {
		int A = scan.nextInt();
		int B = scan.nextInt();
		int C = B;
		
		int length = (int) (Math.log10(B) + 1);
		
		for (int i = 0; i < length; i++) {
			int tmp = C % 10;
			System.out.println(A * tmp);
			C /= 10;
		}
		
		System.out.println(A * B);
	}

}





















################################################################################################################
예제2)2753 윤년

*하드코딩하지않고 상수를 이용
*변수명을 명확하게
*else 사용 x
*개행규칙 적용

https://www.acmicpc.net/problem/2753
################################################################################################################




답:



package backjun;

import java.util.Scanner;

public class Main {
	private static final Scanner scan = new Scanner(System.in);
	public static final int LEAP_YEAR = 1;  
	public static final int COMMON_YEAR = 0;  
	
	public static void main(String[] args) {
		int year = scan.nextInt();
		final int remainderOfYearDividedByFour = year % 4;
		final int remainderOfYearDividedByHundred = year % 100;
		final int remainderOfYearDividedByFourHundred = year % 400;
		
		if (remainderOfYearDividedByFour != 0) {
			System.out.println(COMMON_YEAR);
			return;
		}
		
		if (remainderOfYearDividedByFour == 0 
				&& remainderOfYearDividedByHundred != 0) {
			System.out.println(LEAP_YEAR);
			return;
		}
		
		if (remainderOfYearDividedByFourHundred == 0) {
			System.out.println(LEAP_YEAR);
			return;
		}
		
		System.out.println(COMMON_YEAR);

	}//method
}//class


















################################################################################################################
예제3)14681 사분면 고르기

*함수를 이용해서 main 을 복잡하지 않게
*명확한 변수 식별자 사용

https://www.acmicpc.net/problem/14681
################################################################################################################




답:








package backjun;

import java.util.Scanner;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static int quadrantCheck(int x, int y) {
		if (x > 0 && y > 0) {
			return 1;
		}
		
		if (y > 0 && x < 0) {
			return 2;
		}
		
		if (y < 0 && x < 0) {
			return 3;
		}
		
		if (y < 0 && x > 0) {
			return 4;
		}
		
		return 0;
	}
	
	public static void main(String[] args) {
		int x = scan.nextInt();
		int y = scan.nextInt();
		int quadrant = quadrantCheck(x, y);
		
		System.out.println(quadrant);
	}//method
}//class

























################################################################################################################
예제4)2884 알람 시계(45분일찍)

*함수를 이용해서 main 을 복잡하지 않게
*명확한 변수 식별자 사용
*함수길이 15라인이하

https://www.acmicpc.net/problem/2884
################################################################################################################




답:





package backjun;

import java.util.Scanner;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static int[] correctTime(int H, int M) {
		int[] candidateTime = new int[2];
		boolean flag  = isMinuteImmediatelyApplicable(M); // 시간 차감없이 분만 수정해도 되는지 확인하는 메서드
		
		correctTime(flag, H, M, candidateTime);
		return candidateTime;
	}
	
	private static void correctTime(boolean flag, int H, int M, int[] candidateTime) {
		if (flag) {
			candidateTime[0] = H;
			candidateTime[1] = M - 45;
			return;
		}
		
		if (!flag) {
			correctTime(H, M, candidateTime);
			return;
		}
	}
	
	private static void correctTime(int H, int M, int[] candidateTime) {
		if (H == 0) {
			H = 24;
			candidateTime[0] = H - 1;
			candidateTime[1] = M - 45 + 60;
		}
		
		candidateTime[0] = H - 1;
		candidateTime[1] = M - 45 + 60;
	}
	
	private static boolean isMinuteImmediatelyApplicable(int M) {
		int candidateMinute = M - 45;
		
		if (candidateMinute >= 0) {
			return true;
		}
		
		if (candidateMinute < 0) {
			return false;
		}
		
		return true;
	}
	
	public static void main(String[] args) {
		int H = scan.nextInt();
		int M = scan.nextInt();
		
		int[] candidateTime = correctTime(H, M);
		
		H = candidateTime[0];
		M = candidateTime[1];
		
		System.out.println(H + " " + M);
	}//method
}//class
































































21.12.01.2회차
===============================================================================
*단계별로 풀어보기 1차원배열 ~1546
===============================================================================





































































################################################################################################################
예제5)while 더하기 사이클

https://www.acmicpc.net/problem/1110
################################################################################################################




답:




package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		
		int num = scan.nextInt();
		int count = 0;

		String result = String.valueOf(num);
		
		while (true) {
			int tmp = Integer.parseInt(result);
			if (count != 0 && tmp == num) {
				break;
			}
			
			int ten = tmp / 10;
			int one = tmp % 10;
			
			int add = ten + one;
			int addOne = add % 10;
			
			result = "" + one + addOne;
			count++;
		}
		
		System.out.println(count);

	}//method
}//class

















################################################################################################################
예제6)1차원 배열 최댓값 

*배열에서 특정 값의 인덱스찾기

https://www.acmicpc.net/problem/2562
################################################################################################################




답:
*배열에서 특정 값의 인덱스찾기 : 배열에서 불가능함. list에서 가능함으로 asList로 잠시변환시켜서 거기서 
	indexOf()해서 찾아온다. 다만 list로 변경시킬 배열은 원시자료형이 아니라 객체형이어야한다.
		List<Integer>하듯이(List<int>하지 않잖아?)



package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		Integer[] arr = new Integer[9];
		
		for (int i = 0; i < 9; i++) {
			arr[i] = scan.nextInt();
		}
		
		Integer[] tmp = Arrays.copyOf(arr, 9);
		Arrays.sort(tmp);
		int max = tmp[8];
		
		int index = Arrays.asList(arr).indexOf(max);

		System.out.println(max);
		System.out.println(index+1);
	}//method
}//class





















################################################################################################################
예제7)숫자의 개수 / 1차원배열

https://www.acmicpc.net/problem/2577
################################################################################################################




답:








package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int A = scan.nextInt();
		int B = scan.nextInt();
		int C = scan.nextInt();
		
		String mul = String.valueOf(A * B * C);
		int[] arr = new int[10];
		
		for (int i = 0; i < 10; i++) {
			for (int j = 0; j < mul.length(); j++) {
				if (i == mul.charAt(j) - 48) {
					arr[i]++;
				}
			}
		}

		for (int i = 0; i < 10; i++) {
			System.out.println(arr[i]);
		}
	}//method
}//class




















################################################################################################################
예제8)단계별로 풀어보기 / 1차원배열 / 나머지

*hash만을 이용해서 해도 되지만 1차원배열의 문제이니만큼 배열을 중심으로 다른 컬렉션을 이용하여
	풀도록하여라. 
 

https://www.acmicpc.net/problem/3052
################################################################################################################




답:


*hash만을 이용해서 해도 되지만 1차원배열의 문제이니만큼 배열을 중심으로 다른 컬렉션을 이용하여
	풀도록하여라. : 배열에서 같은 값을 가지는 수의 전체 갯수와 같은 값을 가지는 수가 각각 몇개식 있는지를
		찾아내는 논리가 필요함







package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int[] arr = new int[10];
		
		for (int i = 0; i < 10; i++) {
			arr[i] = scan.nextInt() % 42;
		}
	
		Arrays.sort(arr);
		
		List<Integer> list = new ArrayList<Integer>();
		
		for (int i = 0; i < 10; i++) {
			int count = 1;
			while (i + 1 < 10 && arr[i] != arr[i + 1]) {
				i++;
			}
			
			while (i + 1 < 10 && arr[i] == arr[i+1]) {
				count++;
				i++;
			}
			
			if (count != 1) {
				list.add(count);
			}
		}
		
		int sum = 0;
		for (int i = 0; i < list.size(); i++) {
			sum += list.get(i);
		}
		
		int result = 10 - sum + list.size();
		
		System.out.println(result);
		
	}//method
}//class






















################################################################################################################
예제9)단계별로 풀어보기 / 1차원배열 / 평균

https://www.acmicpc.net/problem/1546
################################################################################################################




답:








package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int count = scan.nextInt();
		int[] arr = new int[count];
		
		for (int i = 0; i < count; i++) {
			arr[i] = scan.nextInt();
		}
		
		Arrays.sort(arr);
		int max = arr[count-1];
		
		double sum = 0;
		
		for (int i = 0; i < count; i++) {
			double scoreChange = (arr[i] / (double) max) * 100;
			sum += scoreChange;
		}
		
		double scoreResult = sum / count;
		
		System.out.println(scoreResult);
	}//method
}//class



























































































21.12.02.3회차
===============================================================================
*단계별로 풀어보기 1차원배열 ~1546
===============================================================================































































































################################################################################################################
예제10)단계별로 풀어보기 / 1차원배열 / OX퀴즈

*A
-입력되는 퀴즈정답 문자열을 모두 입력받아 배열에 저장한 후 값판별하여 출력
	-List의 List를 사용하는 법을 익혀보자.
	-정답인 인덱스들만 따로 추출한뒤 앞의 연속되거나 연속되지 않을 인덱스값들과 비교하여 해당 인덱스의
		점수를 판별하라
*B
-하나 입력받고 하나 출력해라
-위 A와 반대로 0번인덱스부터 올라가며 정답인 인덱스의 점수들을 유추하라

https://www.acmicpc.net/problem/8958
################################################################################################################




A답:





package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int count = scan.nextInt();
		String[] arr = new String[count];
		
		for (int i = 0; i < count; i++) {
			arr[i] = scan.next();
		}
		
		
		ArrayList<ArrayList<Integer>> indexLists = new ArrayList<ArrayList<Integer>>();
		int[] tmp = new int[count];
		
		for (int i = 0; i < count; i++) {
			for (int j = 0; j < arr[i].length(); j++) {
				if (arr[i].charAt(j) == 'O') {
					indexLists.add(new ArrayList<Integer>());
					indexLists.get(i).add(j);
				}
			}
			
			int sum = 0;
			
			for (int j2 = indexLists.get(i).size() - 1; j2 >= 0; j2--) {
				int num = 1;
				int j3 = 1;
				while (j2 - j3 >= 0 && indexLists.get(i).get(j2) - j3 == indexLists.get(i).get(j2 - j3)) {
					num++;
					j3++;
				}
				6
				sum += num;
			}
			
			tmp[i] = sum;
		}
		
		for (int i = 0; i < count; i++) {
			System.out.println(tmp[i]);
		}
		
	
	}//method
}//class















B답:


package backjun;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.io.IOException;
public class Main{
    public static void main(String[] args)throws IOException{
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        
        int n = Integer.parseInt(br.readLine());
        String s;
        int count = 0;
        int sum = 0;
        for(int i = 0; i<n; i++){
            s = br.readLine();
            for(int j = 0; j<s.length(); j++){
                if(s.charAt(j) == 'O')
                    count++;
                else
                    count = 0;
                sum += count;
            }        
            bw.write(sum + "\n");
            sum = 0;    
            count = 0;          
        }
        br.close();
        bw.close();
        
    }
}


























































21.12.06.4회차
===============================================================================
*단계별로 풀어보기 
===============================================================================


























































################################################################################################################
예제11)단계별로 풀어보기 / 1차원배열 / 평균은 넘겠지


https://www.acmicpc.net/problem/4344
################################################################################################################




답:









package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int caseCount = scan.nextInt();
	
		for (int i = 0; i < caseCount; i++) {
			int countInCase = scan.nextInt();
			int[] arr = new int[countInCase];
			int sum = 0;
			
			for (int j = 0; j < countInCase; j++) {
				arr[j] = scan.nextInt();
				sum += arr[j];
			}
			
			double avg = sum / (double) countInCase;
			
			Arrays.sort(arr);
			
			int j = countInCase - 1;
			int count = 0;
			
			while (arr[j] > avg) {
				count++;
				j--;
			}
			
			double result = ((double) count / countInCase) * 100;
			System.out.printf("%.3f%%\n", result);
		}
	
	}//method
}//class

























################################################################################################################
예제12)단계별로 풀어보기 / 함수 / 셀프넘버

*출력할때 selfNumber를 검사하면서 매번 출력하면 속도가 느리니까 문자열을 업그레이드한 api를 이용하여
 	하나로 만든 뒤 한번의 출력만을 사용하라.

https://www.acmicpc.net/problem/4673
################################################################################################################




답:


package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		boolean[] notSelfNumber = new boolean[10001];
		
		for (int i = 1; i < 10001; i++) {
			int numberWithConstructor = d(i);
			
			if (numberWithConstructor > 10000) {
				continue;
			}
			
			notSelfNumber[numberWithConstructor] = true; // notSelfNumber 배열 내에 값이 true인 index는 selfNumber가 아닌 것이다.  
		}
		
		findSelfNum(notSelfNumber);
	}//method
	
	public static int d(int n) {
		int tmp = n;
		int sum = n;
		
		while (tmp != 0) {
			sum += tmp % 10;
			tmp /= 10;
		}
		
		return sum;
	}
	
	public static void findSelfNum(boolean[] notSelfNumber) {
		StringBuilder sb = new StringBuilder();
		
		for (int i = 1; i <= 10000; i++) {
			if (!notSelfNumber[i]) {
				sb.append(i).append('\n');
			}
		}
		
		System.out.println(sb);
	}
}//class























################################################################################################################
예제13)단계별로 풀어보기 / 함수 / 한수

*list의 내림차순정렬, 오름차순정렬을 연습해봐라
*list의 내용을 뒤집어봐라

https://www.acmicpc.net/problem/1065
################################################################################################################




답:





package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int number = scan.nextInt();
		int answer = checkNumber(number);
		System.out.println(answer);
	}//method

	
	public static int checkNumber(int number) {
		if (number < 100) {
			return number;
		}
		
		int count = 99;
		for (int i = 100; i <= number; i++) {
			List<Integer> list = getTheDigits(i);
			boolean arithmeticSequence = isArithmeticSequence(list);
			
			if (arithmeticSequence) {
				count++;
			}
		}
		
		return count;
	}
	
	
	private static ArrayList<Integer> getTheDigits(int number) {
		ArrayList<Integer> list = new ArrayList<Integer>();
		
		while (number != 0) {
			list.add(number % 10);
			number /= 10;
		}
		
		Collections.reverse(list);
		return list;
	}
	
	private static boolean isArithmeticSequence(List<Integer> list) {
		boolean flag = true;
		int defaultDifference = list.get(0) - list.get(1);
		
		for (int i = 1; i < list.size()-1; i++) {
			int nowDifference = list.get(i) - list.get(i+1);
			
			if (nowDifference != defaultDifference) {
				flag = false;
				break;
			}
		}
		
		return flag;
	}
}//class

























################################################################################################################
예제14)단계별로 풀어보기 / 문자열 / 단어공부

*두번째 답으로도 풀어보시오(성능은 내가 푼게 더 좋음 메모리, 속도)

https://www.acmicpc.net/problem/1157
################################################################################################################




내 답(중복되는 문자 제거한 후 각 문자가 문자열에서 몇개있는지 확인하여 max값 구한 뒤 해당하는 문자 출력):






package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		String str = scan.next();
		
		String tmp = str.toUpperCase();
		List<Integer> list = new ArrayList<Integer>();
		List<Character> list2 = new ArrayList<>();
		Set<Character> set = new HashSet<>();
		
		for (int i = 0; i < tmp.length(); i++) {
			set.add(tmp.charAt(i));
		}
		
		Iterator<Character> iter = set.iterator();

		while (iter.hasNext()) {
			char ch = iter.next();
			int count = charCount(tmp, ch);
			list.add(count);						
			list2.add(ch);						
		}

		int max = list.get(0);
		int idx = 0;
		
		for (int i = 1; i < list.size(); i++) {
			if (max < list.get(i)) {
				max = list.get(i);
				idx = i;
			}
		}
		
		int count = 0;
		for (int i = 0; i < list.size(); i++) {
			if (max == list.get(i)) {
				count++;
			}
		}
		
		if (count > 1) {
			System.out.println("?");
		} else {
			System.out.println(list2.get(idx));
		}
	}//method
	
	public static int charCount(String str, char ch) {
		return str.length() - str.replace(String.valueOf(ch), "").length();
	}
}//class












다른사람 답(알파벳 배열 26개 크기 만들고 하나하나 살펴서 알파벳당 갯수 세기):




import java.util.Scanner;

public class Main {
    public static void main(String[] args) {

        Scanner scan = new Scanner(System.in);
        String[] str = scan.nextLine().toUpperCase().replace(" ", "").split("");
        int[] array = new int[26];
        char result = '?';
        int j = 0;
        for (String s : str) {
            array[s.charAt(0) - 65] += 1;
        }
        for (int i = 0; i < array.length; i++) {
            if (j < array[i]) {
                result = (char) (i + 65);
                j = array[i];
            } else if (j == array[i]) {
                result = '?';
            }
        }
        System.out.println(result);
        scan.close();
    }
}






































































































21.12.07.5회차
===============================================================================
*단계별로 풀어보기 
===============================================================================

















































































################################################################################################################
예제15)단계별로 풀어보기 / 문자열 / 단어공부

*지문에는 문자 사이에 공백이 있다면 단 하나라고 되어있지만 여러개가 올수 있다고 가정하고서 문제를 풀어라
*주의)split은 문자열의 특정 단어를 기준으로 문자열을 나누는 것인데 이때 나눠져야하는 단어가 공백만 있을경우 단어로 취급하지
 않으며 배열자체는 하나의 크기로 비어있는 채로 생성된다.
*나눠야하는 문자열에 공백이 아닌 단어가 하나라도 있다면 해당 단어 앞의 공백들은 
	""으로(빈문자열) 생성되어 나누어진다.
		String str2 = "                     ";
		String[] tmp = str2.split(" ");
		
		System.out.println(tmp.length);
		System.out.println(Arrays.toString(tmp));

https://www.acmicpc.net/problem/1152
################################################################################################################




답:

*문자열은 대소문자와 공백으로 이루어졌다. 이말은 대소문자만 하나 있거나 공백만 하나 있을수도 있다는 소리이다.
*그리고 문자가 시작되기전의 공백은 제거해주어야 
package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		String str = scan.nextLine().trim().replaceAll(" +", " ");
		if (str.length() == 0) {
			System.out.println(0);			
		} else {
			String[] tmp = str.split(" ");
			System.out.println(tmp.length);			
		}
	}
}//class



























################################################################################################################
예제16)단계별로 풀어보기 / 문자열 / 상수(사람이름)

*StringBuilder 또는 List 또는 배열을 이용해서 풀수있는데 StringBuilder를 이용해서푼다.
	-StringBuilder 초기화시에 입력받은 문자열을 이용해서 초기화법을 익힌다.
	-다시 숫자로 변환할때 String만 변환가능함을 인지하고 String형으로 바꾸는 법을 익힌다.

https://www.acmicpc.net/problem/1152
################################################################################################################




답:




package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		String A = scan.next();
		String B = scan.next();
		
		StringBuilder sbA = new StringBuilder(A);
		StringBuilder sbB = new StringBuilder(B);
		sbA.reverse();
		sbB.reverse();
		
		int intA = Integer.parseInt(sbA.toString());
		int intB = Integer.parseInt(sbB.toString());
		
		int result = Math.max(intA, intB);
		
		System.out.println(result);
	}
}//class




















################################################################################################################
예제17)단계별로 풀어보기 / 문자열 / 다이얼

*인덱스를 배열에 접근하기 위한 데이터 의미 외에도 유의미한 데이터로 이용해서 푸는 연습

https://www.acmicpc.net/problem/1152
################################################################################################################




답:




package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		String[] location = {"", " ", "ABC", "DEF", "GHI", "JKL", "MNO", "PQRS", "TUV", "WXYZ"};
		String telStr = scan.next();
		
		int sum = 0;
		
		for (int i = 0; i < telStr.length(); i++) {
			for (int j = 1; j < location.length; j++) {
				if (location[j].contains(String.valueOf(telStr.charAt(i)))) {
					sum += j + 1;
					break;
				}
 			}
		}
		
		System.out.println(sum);
	}
}//class























################################################################################################################
예제18)단계별로 풀어보기 / 문자열 / 크로티아 알파벳

*다풀고나서 아래 답 밑의 개념 확인할것

https://www.acmicpc.net/problem/2941
################################################################################################################




답:

*replaceAll을 이용한 정규식 및 연산자
-str.replaceAll("[abc]", "왕"); // a b c 각각의 문자가 있다면 모두 왕으로 변경
	str.replaceAll("a", "왕"); //현재 줄포함 아래처럼 할 필요없음
	str.replaceAll("b", "왕");
	str.replaceAll("c", "왕");
-str.replaceAll("[0-9]", ""); // 문자열 내의 숫자[0-9] 모두 빈문자열로 변경
-str.replaceAll("[^0-9]", ""); // 문자열 내의 숫자[0-9] 외의 것을 모두 빈문자열로 변경
					//숫자만 문자열에 남겨두는 법
-str.replaceAll(" +", ""); // 공백뭉쳐있는걸 하나의 공백으로 변경

package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		String[] specialWords = {"c=", "c-", "dz=", "d-", "lj", "nj", "s=", "z="};
		String words = scan.next();
		
		
		for (int i = 0; i < specialWords.length; i++) {
			words = words.replace(specialWords[i], "A");
		}

		int count = words.length();

		System.out.println(count);
		
	}
}//class























################################################################################################################
예제19)단계별로 풀어보기 / 문자열 / 그룹 단어 제거


https://www.acmicpc.net/problem/1316
################################################################################################################




답:






package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int number = scan.nextInt();
		
		int count = 0;
		
		for (int index = 0; index < number; index++) {
			String words = scan.next();
			int i = 0;
			boolean flag = false;
			
			while (i < words.length()) {
				int tmp = i;
				
				while (i < words.length() - 1 && words.charAt(i) == words.charAt(i+1)) {
					i++;
				}
				
				int tmp2 = i;
				
				while (tmp2 < words.length() - 1 && words.charAt(tmp) != words.charAt(tmp2 + 1)) {				
					tmp2++;
				}
				
				if (tmp2 != words.length() - 1) {
					flag = true;
					break;
				}
				
				i++;
			}
			
			if (!flag) {
				count++;
			}			
		}
		
		System.out.println(count);
	}
}//class















################################################################################################################
예제20)단계별로 풀어보기 / 기본수학 / 손익분기점

*while로하면 시간에러난다. 식 정리에 유의하라

https://www.acmicpc.net/problem/1316
################################################################################################################




답 :



package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int A = scan.nextInt();
		int B = scan.nextInt();
		int C = scan.nextInt();
		
		long count = gameStart(A, B, C);
		System.out.println(count);
	}
	
	public static long gameStart(long a, long b, long c) {		
		if (c - b <= 0) {
			return -1;
		}
		
		long result = a / (c - b) + 1;
		
		return result;
	}
}//class

























































































21.12.08.6회차
===============================================================================
*단계별로 풀어보기 
===============================================================================





































































################################################################################################################
예제21)단계별로 풀어보기 / 기본수학 / 벌집

*답이 2개인데 하나는 확실하게 그림상에서 이전 단계와 다음단계의 범위를 나눠 준것이고 B는 다음 단계만을 확인한것
	-최초 푼 답 : A, 개선한 답 : B

https://www.acmicpc.net/problem/2292
################################################################################################################




답 A:


package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int num = scan.nextInt();
		
		int before = 0;
		int start = 1;
		int count = 1;
		
		while (num <= before || num > start) {
			before = start;
			start = (6 * count) + before;
			count++;
		}
		
		System.out.println(count);
	}
}//class







답 B:


package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int num = scan.nextInt();
		
		int start = 1;
		int count = 1;
		
		while (num > start) {
			start += (6 * count);
			count++;
		}
		
		System.out.println(count);
	}
}//class
















################################################################################################################
예제22)단계별로 풀어보기 / 기본수학 / 분수찾기

*답B로 풀어라

https://www.acmicpc.net/problem/1193
################################################################################################################




답 A(내가 푼 답 _ 기계적임. 마지막에 수학적 계산이 안들어갔기때문에 답 B가 더 문제에 맞다):

package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int num = scan.nextInt();
		
		
		int line = 1;
		int count = 1;
		
		while (count < num) {
			line++;
			count += line;
		}
		
		String str = "";
		
		int hang = 0;
		int yul = 0;
		int location = num - (count - line);
		int i = 1;
		
		
		if (line % 2 == 0) { // 짝수면 위에서 아래
			hang = 1;
			yul = line;
			
			while (i < location) {
				hang++;
				yul--;
				i++;
			}
		} else { // 홀수라인이면 아래에서 위
			hang = line;
			yul = 1;
			
			while (i < location) {
				hang--;
				yul++;
				i++;
			}
		}
		
		str = hang + "/" + yul;
		System.out.println(str);
	}
}//class







답 B(다른사람 답을 참고하여 재작성한 답):

package backjun;

import java.util.*;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) {
		int num = scan.nextInt();
		
		int nowCross = 1;
		int totalCountOfPrevCrossLines = 0;
		
		while (true) {
			if (nowCross + totalCountOfPrevCrossLines >= num) {
				if (nowCross % 2 != 0) {
					System.out.println(nowCross - (num - totalCountOfPrevCrossLines - 1) 
							+ "/" + (num - totalCountOfPrevCrossLines));
					break;
				} else {
					System.out.println((num - totalCountOfPrevCrossLines) 
							+ "/" + (nowCross - (num - totalCountOfPrevCrossLines - 1)));
					break;
				}
			} else {
				totalCountOfPrevCrossLines += nowCross;
				nowCross++;
			}
		}
	}
}//class


























################################################################################################################
예제23)단계별로 풀어보기 / 기본수학 / 달팽이는 올라가고 싶다 

** 입출력 버퍼사용 연습문제

https://www.acmicpc.net/problem/2869
################################################################################################################



답 :




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {
//	private static final Scanner scan = new Scanner(System.in);  
	// 이거 scan 주석처리 안하면 시간초과됨
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine(), " ");
												//, " " 해도되고 안해도 됨 근데 한게 속도가 더 빠름
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		int A = Integer.parseInt(st.nextToken());
		int B = Integer.parseInt(st.nextToken());
		int V = Integer.parseInt(st.nextToken());
		
		
		int i = (V-B) / (A-B);
		
		if ((V-B) % (A-B) != 0) {
			i++;
		}

		bw.write(String.valueOf(i));
		bw.newLine();
		bw.flush();
		
		br.close();
		bw.close();
	}
}//class
















































































21.12.09.7회차
===============================================================================
*단계별로 풀어보기 
===============================================================================





################################################################################################################
예제24)단계별로 풀어보기 / 기본수학 / ACM 호텔

*101 102 등을 만들기위해 층을 뺀 1~9의 수 앞에는 0을 붙여줘야한다. 이때 1~9인 수를 특정할때 조건문으로 10보다 작은 경우로 할수있지만
	정수의 자릿수를(길이) 표현하는 방법을 연습하기 위해서 조건을 1의 자리가 아닌경우로 설정해서 특정하라

https://www.acmicpc.net/problem/10250
################################################################################################################


답 : 

package backjun;
import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {
	private static final Scanner scan = new Scanner(System.in);  
	
	public static void main(String[] args) throws IOException {	
		int count = scan.nextInt();
		
		for (int i = 0; i < count; i++) {
			int height = scan.nextInt();
			int width = scan.nextInt(); 
			int customerNumber = scan.nextInt();
			
			int share = customerNumber / height + 1;
			int remainder = customerNumber % height;
			
			if (remainder == 0) {
				remainder = height;
				share -= 1;
			}
			
			
			String shareChange = String.valueOf(share);
			
			int length = (int) (Math.log10(share) + 1);
			
			if (length == 1) {
				shareChange = "0" + String.valueOf(share);
			}
//			if (share < 10) {
//				shareChange = "0" + String.valueOf(share);
//			}
			
			System.out.println(remainder + shareChange);
		}
		
	}
}//class










################################################################################################################
예제25)단계별로 풀어보기 / 기본수학 / 부녀회장이 될테야

*하드코딩하지말고 각 수를 상수화시켜 풀어라.
*속도를 빠르게하기위해서 System.println()과 scanner를 사용하지 않는다.
*출력은 단 한번만 하도록 한다.

https://www.acmicpc.net/problem/2775
################################################################################################################


답 : 

package backjun;
import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {
	private static final Scanner scan = new Scanner(System.in);
	private static final int ZERO_FLOOR = 0;
	private static final int FIRST_FLOOR = 1;
	private static final int TOP_FLOOR = 14;
	
	private static final int FIRST_ROOM = 1;
	private static final int SECOND_ROOM = 2;
	private static final int LAST_ROOM = 14;
	
	private static final int ONE_PEOPLE = 1;
	
	private static int[][] apt = new int[TOP_FLOOR + 1][LAST_ROOM + 1]; 
	
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		StringBuilder sb = new StringBuilder();
		
		int T = Integer.parseInt(br.readLine());
		
		makeApt();
		
		for (int i = 0; i < T; i++) {
			int floor = Integer.parseInt(br.readLine());
			int room = Integer.parseInt(br.readLine());
			
			sb.append(apt[floor][room]).append("\n");
		}
		
		bw.write(sb.toString());
		bw.newLine();
		bw.flush();
		bw.close();
		
		br.close();
	}
	
	public static void makeApt() {
		for (int i = FIRST_FLOOR; i <= TOP_FLOOR ; i++) {
			apt[i][FIRST_ROOM] = ONE_PEOPLE; // 층
			apt[ZERO_FLOOR][i] = i; // 호
		}
		
		for (int i = FIRST_FLOOR; i <= TOP_FLOOR; i++) {
			for (int j = SECOND_ROOM; j <= LAST_ROOM; j++) {
				apt[i][j] = apt[i][j - 1] + apt[i - 1][j];
			}
		}
	}
}//class













































































































21.12.13.8회차
===============================================================================
*단계별로 풀어보기 
===============================================================================














































































################################################################################################################
예제26)단계별로 풀어보기 / 기본수학 / 설탕배달

https://www.acmicpc.net/problem/2839
################################################################################################################


답 : 


***규칙찾기
n = 입력되는 양
c = 입력되는 양의 포장갯수(count)
/ = n /5 의 값들의 집한인 행임을 의미하는 기호
% = n % 5 의 값들의 집합인 행임을 의미하는 기호
x = -1;

n 3 4 	5 6 7 8 9 	10 11 12 13 14 		15 16 17 18 19		20 21 22 23 24
c 1 x 	1 2 x 2 3  	2  3  4  3  4  		3   4 5  4   5           4  5  6  5 6
/ 0 0 	1 1 1 1 1  	2  2  2  2  2  		3   3 3  3   3		 4  4  4  4 4
% 3 4 	0 1 2 3 4  	0  1  2  3  4  		0   1  2  3  4           0  1  2  3  4 




package backjun;
import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {
//	private static final Scanner scan = new Scanner(System.in);
	private static final int FIVE_KG = 5;

	
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		

		int total = Integer.parseInt(br.readLine());
		int result = calcCount(total);

		
		bw.write(String.valueOf(result));
		bw.newLine();
		bw.flush();
		bw.close();
		br.close();
	}
	
	
	public static int calcCount(int total) {
		if (total == 7 || total == 4) {
			return -1;
		}
		
		int fiveKgCount = total / FIVE_KG;		
		int remainder = total % FIVE_KG;
		
		if (remainder == 0) {
			return fiveKgCount;
		}
		
		if (remainder == 1 || remainder == 3) {
			return fiveKgCount + 1;
		}
		
		if (remainder == 2 || remainder == 4) {
			return fiveKgCount + 2;
		}
		
		return 0;
	}
}//class



















################################################################################################################
예제27)단계별로 풀어보기 / 기본수학 / 큰 수 A+B

*API를 이용해서 간단히 풀기
*String과 int배열을 이용해서 복잡하게 풀어보기

https://www.acmicpc.net/problem/10757
################################################################################################################


API를 이용한 답 : 

package backjun;
import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {
//	private static final Scanner scan = new Scanner(System.in);

	
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringTokenizer st = new StringTokenizer(br.readLine());

		BigInteger A = new BigInteger(st.nextToken());
		BigInteger B = new BigInteger(st.nextToken());
		A = A.add(B);
		
		bw.write(String.valueOf(A));
		bw.newLine();
		
		bw.flush();
		bw.close();
		br.close();
	}
}//class



String과 int배열을 이용한 답 :

package backjun;
import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {
//	private static final Scanner scan = new Scanner(System.in);

	
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringTokenizer st = new StringTokenizer(br.readLine());
		StringBuilder sb = new StringBuilder();
		
		String strA = st.nextToken();
		String strB = st.nextToken();

		int maxLength = Math.max(strA.length(), strB.length());
		int[] A = new int[maxLength];
		int[] B = new int[maxLength];
		int[] result = new int[maxLength + 1];
		
		for (int i = strA.length() - 1, index = 0; i >= 0; i--, index++) {
			A[index] = strA.charAt(i) - 48;
		}

		for (int i = strB.length() - 1, index = 0; i >= 0; i--, index++) {
			B[index] = strB.charAt(i) - 48;
		}
		
		for (int i = 0; i < maxLength; i++) {
			int value = A[i] + B[i];
			result[i] += value;
			result[i + 1] = result[i] / 10;
			result[i] %= 10;
		}
		
		
		if (result[maxLength] != 0) {
			sb.append(1);
		}
		
		for (int i = maxLength - 1; i >= 0; i--) {
			sb.append(result[i]);
		}
		
		bw.write(sb.toString());
		bw.newLine();
		
		bw.flush();
		bw.close();
		br.close();
	}
}//class













































21.12.14.9회차
===============================================================================
*단계별로 풀어보기 
===============================================================================





































################################################################################################################
예제28)단계별로 풀어보기 / 기본수학 / Fly me to the Alpha Centauri

*출력은 단 한번만 사용하라.
*빠른 입출력을 사용하라.

https://www.acmicpc.net/problem/1011
	-참)https://st-lab.tistory.com/79
################################################################################################################


답 : 


count	distance	move			max
1	1		1			1
2	2		1 1			1
3	4		1 2 1			2
4	6		1 2 2 1			2
5	9		1 2 3 2 1		3
6	12		1 2 3 3 2 1		3
7	16		1 2 3 4 3 2 1		4
8	20		1 2 3 4 4 3 2 1		4
9	25		1 2 3 4 5 		5
			4 3 2 1
10	30		1 2 3 4 5		5
			5 4 3 2 1


		o			o					o							o
distance	1	2	3	4	5	6	7	8	9	10	11	12	13	14	15	16
count		1	2	3	3	4	4	5	5	5	6	6	6	7	7	7	7
max		1	1	1	2	2	2	2	2	3	3	3	3	3	3	3	4
		

										o					
distance	17	18	19	20	21	22	23	24	25	26	27	28	29	30	
count		8	8	8	8	9	9	9	9	9
max		4	4	4	4	4	4	4	4	5


1) max는 distance의 루트값에서 소수점을 땐 값 
int max = (int) Math.sqrt(distance);
 

2) max와 distance의 루트값에서 소수점을 때지않은 값이 같으면 max가 변하는 구간이고 맥스가 변하는 구간은 max * 2 + 1을 하면 count값이 나옴
if (max == Math.sqrt(distance)) {
	print(max * 2 - 1);
	return;
}

3)max * max < distance <= (max * max) + max

if (distance <= (max * max) + max) {
	print(max * 2);
	return;
}


4)(max * max) + max < distance < (max * max) + 2max

if (distance < (max * max) + 2max) { //else 해도 됨 ===================================> 이렇게하니깐 안됐음. else를 해야만 함.. 
	print(max * 2 + 1);	
}





package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {
//	private static final Scanner scan = new Scanner(System.in);	
	public static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		int T = Integer.parseInt(br.readLine());
		
		for (int i = 0; i < T; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int x =  Integer.parseInt(st.nextToken());
			int y = Integer.parseInt(st.nextToken());
			int distance = y - x;
			
			calcCount(distance);
		}
		
		
		bw.write(sb.toString());
		bw.newLine();
		bw.flush();
		bw.close();
		
		br.close();
	}
	
	public static void calcCount(int distance) {
		int max = (int) Math.sqrt(distance);
		
		if (max == Math.sqrt(distance)) {
			sb.append(max * 2 - 1).append("\n");
			return;
		}
		
		if (distance <= (max * max) + max) {
			sb.append(max * 2).append("\n");
			return;
		}
		
		else {
			sb.append(max * 2 + 1).append("\n");
			return;
		}
		
	}
}//class






















################################################################################################################
예제29)단계별로 풀어보기 / 기본수학2 / 소수 찾기

https://www.acmicpc.net/problem/1978
################################################################################################################


답 : 




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {
//	private static final Scanner scan = new Scanner(System.in);	
	public static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		int T = Integer.parseInt(br.readLine());
		int count = 0;
		
		StringTokenizer st = new StringTokenizer(br.readLine());

		for (int i = 0; i < T; i++) {
			int num = Integer.parseInt(st.nextToken());
			if (calc(num)) {
				count++;
			}
		}
		
		
		bw.write(String.valueOf(count));
		bw.newLine();
		bw.flush();
		bw.close();
		
		br.close();
	}
	
	
	public static boolean calc(int num) {
		boolean flag = true;
		
		if (num == 1) {
			return false;
		}
		
		for (int i = 2; i <= (int) Math.sqrt(num); i++) { // int 캐스팅연산안해도 됨
			if (num % i == 0) {
				flag = false;
				break;
			}
		}
		
		return flag;
	}
	
}//class




















################################################################################################################
예제30)단계별로 풀어보기 / 기본수학2 / 소수

https://www.acmicpc.net/problem/2581
################################################################################################################


답 : 



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	public static List<Integer> list = new ArrayList<>();
	public static int sum = 0;
	
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		int start = Integer.parseInt(br.readLine());
		int end = Integer.parseInt(br.readLine());
		
		gather(start, end);
		
		if (list.isEmpty()) {
			bw.write(String.valueOf(-1));
			bw.flush();
			bw.close();
			br.close();
			return;
		}
		
		Collections.sort(list);
		int min = list.get(0);
		
		bw.write(String.valueOf(sum));
		bw.newLine();
		bw.write(String.valueOf(min));
		bw.flush();
		bw.close();
		
		br.close();
	}
	
	public static int gather(int start, int end) {
		
		for (int i = start; i <= end; i++) {
			if (calc(i)) {
				list.add(i);
				sum += i;
			}
		}
		
		return 0;
	}
	
	private static boolean calc(int num) {
		boolean flag = true;
		
		if (num == 1) {
			return false;
		}
		
		for (int i = 2; i <= (int) Math.sqrt(num); i++) {
			if (num % i == 0) {
				flag = false;
				break;
			}
		}
		
		return flag;
	}
	
}//class















################################################################################################################
예제31)단계별로 풀어보기 / 기본수학2 / 소인수분해


https://www.acmicpc.net/problem/11653
################################################################################################################


답 : 

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	public static List<Integer> list = new ArrayList<>();
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		int num = Integer.parseInt(br.readLine());
		if (num == 1) {
			return;
		}
		
		calc(num);
		for (int i = 0; i < list.size(); i++) {
			bw.write(String.valueOf(list.get(i)));
			bw.newLine();
		}

		bw.flush();
		bw.close();		
		br.close();
	}

	public static void calc(int num) {
		for (int i = 2; i <= num; i++) {
			num = calc(i, num);
			
			if (num == 1) {
				break;
			}
		}
	}
	
	private static int calc(int i, int num) {
		while (num % i == 0) {
			num /= i;		
			list.add(i);
		}
		
		return num;
	}
}//class
























































21.12.20.10회차
===============================================================================
*단계별로 풀어보기 
===============================================================================















































################################################################################################################
예제32)단계별로 풀어보기 / 기본수학2 / 소수구하기

*에라토스테네스의 체

https://www.acmicpc.net/problem/1929
################################################################################################################


답 : 



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	public static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine());		
		
		int start = Integer.parseInt(st.nextToken());
		int end = Integer.parseInt(st.nextToken());
		
		int[] sieve = new int[end + 1];
		sieve[0] = 1;
		sieve[1] = 1;  // 이거 안하면 1도 소수로 출력한다.
		
		usePrimeNumberSieve(sieve, end);
		findPrimeNumber(sieve, start, end);
		
		bw.flush();
		bw.close();
		
		br.close();
	}
	
	public static void usePrimeNumberSieve(int[] sieve, int end) {
		for (int i = 2; i <= end; i++) {
			if (sieve[i] == 0 && (long) i * i <= end) {
				usePrimeNumberSieve(sieve, end, i);				
			}
		}		
	}
	
	private static void usePrimeNumberSieve(int[] sieve, int end, int i) {
		for (int j = i * i; j <= end; j += i) {
			sieve[j] = 1;
		}
	}

	public static void findPrimeNumber(int[] sieve, int start, int end) throws IOException {
		for (int i = start; i <= end; i++) {
			if (sieve[i] == 0) {
				bw.write(String.valueOf(i));
				bw.newLine();
			}
		}
	}
}//class






















################################################################################################################
예제33)단계별로 풀어보기 / 기본수학2 / 베르트랑 공준

*에라토스테네스의 체는 위에서 사용했으니 일반 방식으로 다시 풀어봐라
	-제곱근을 이용한 소수찾기

https://www.acmicpc.net/problem/4948
################################################################################################################


답 : 

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	public static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		getPrimeNumberCount(br);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void getPrimeNumberCount(BufferedReader br) throws IOException {
		while (true) {
			int n = Integer.parseInt(br.readLine());
			if (n == 0) break;
			
			int count = getPrimeNumberCount(n);
			bw.write(String.valueOf(count));
			bw.newLine();
		}	
	}
	
	private static int getPrimeNumberCount(int n) {
		int count = 0;
		
		for (int i = n + 1; i <= n * 2; i++) {
			if (isPrimeNumber(i)) {
				count++;
			}
		}
		
		return count;
	}
	
	private static boolean isPrimeNumber(int i) {
		for (int j = 2; j <= Math.sqrt(i); j++) {
			if (i % j == 0) {
				return false;
			}
		}
		
		return true;
	}
}//class











################################################################################################################
예제34)단계별로 풀어보기 / 기본수학2 / 골드바흐의 추측

*에라토스테네스의 체를 이용하여 풀어라
	-앞문제에서는 int[]를 이용하여 풀었지만 이번문제에서는 boolean으로 true일경우
		소수, false일경우 소수가 아닌수로 하여라
		-처음 boolean 배열 만들면 모두 false인데 모두 true로 만드는 api를 이용하라
	-에라토네스의 체 범위만들때 하드코딩하지 말것
	-에라토네스의 체 범위안의 수들을 하나하나 대입해서 배수의 값을 변경해왔다면 이번에는
		for문이 끝나는 제한을 다르게 넣어라(훨씬 빠르다)
		-생각잘하면 i <= MAX_PRIME_NUMBER로 안해도된다.
		-범위가 2~20이고 i가 5일때 5 * 5 는 25인데 범위를 넘어간다.
			6 ~ 20 사이의 소수의 배수값에(소수가 아니라면 이미 값은 변경돼있다) 해당하는 인덱스들의 값을 바꿔줄 필요가 없다.

https://www.acmicpc.net/problem/9020
################################################################################################################


답 : 




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

//	20 24 28
//2 3 5 7 11 13 17 19

public class Main {	
	public static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	public static final int MAX_PRIME_NUMBER = 9999;
	public static boolean[] check = new boolean[MAX_PRIME_NUMBER + 1];
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		Arrays.fill(check, true);
		check[0] = false;
		check[1] = false;
		
		startSieveOfEratos();
		
		int count = Integer.parseInt(br.readLine());
		for (int i = 0; i < count; i++) {
			getPartition(Integer.parseInt(br.readLine()));
		}
		
		bw.flush();
		bw.close();
		br.close();
	}

	public static void startSieveOfEratos() {
		for (int i = 2; i * i <= MAX_PRIME_NUMBER; i++) { // 소수의 범위는 2~ 9999사이
			if (check[i]) {
				changeArray(i);
			}
		}
	}
	
	private static void changeArray(int i) {
		for (int j = i * i; j <= MAX_PRIME_NUMBER; j += i) {
			check[j] = false;
		}
	}

	public static void getPartition(int n) throws IOException {
		for (int i = n / 2; i >= 2; i--) {
			if (check[i] && check[n - i]) {
				bw.write("" + i + " " + (n - i));
				bw.newLine();				
				return;
			}
		}
	}
	
}//class















################################################################################################################
예제35)단계별로 풀어보기 / 기본수학2 / 직사각형에서 탈출

https://www.acmicpc.net/problem/1085
################################################################################################################


답 : 




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		int x = Integer.parseInt(st.nextToken());
		int y = Integer.parseInt(st.nextToken());
		int w = Integer.parseInt(st.nextToken());
		int h = Integer.parseInt(st.nextToken());
		
//		int heightH = h - y;
//		int heightZero = y; // y - 0
//		int heightMin = Math.min(heightH, heightZero);
		
//		int wideW = w - x;
//		int wideZero = x; // x - 0
//		int wideMin = Math.min(wideW, wideZero);

		int height = Math.min(h - y, y);
		int wide = Math.min(w - x, x);
		int result = Math.min(height, wide);
		
		bw.write(String.valueOf(result));
		bw.newLine();
		
		bw.flush();
		bw.close();
		
		br.close();
	}
	
}//class

















################################################################################################################
예제36)단계별로 풀어보기 / 기본수학2 / 네번째 점


https://www.acmicpc.net/problem/3009
################################################################################################################


답 : 



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	
	public static void main(String[] args) throws IOException {	
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
		int[][] locations = new int[3][2];
		
		for (int i = 0; i < 3; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			locations[i][0] = Integer.parseInt(st.nextToken());				
			locations[i][1] = Integer.parseInt(st.nextToken());				
		}
			
		int x = 0;
		int y = 0;
	
		if (locations[0][0] == locations[1][0]) {
			x = locations[2][0];
		} else if (locations[0][0] == locations[2][0]) {
			x = locations[1][0];
		} else if (locations[1][0] == locations[2][0]) {
			x = locations[0][0];
		}
		
		if (locations[0][1] == locations[1][1]) {
			y = locations[2][1];
		} else if (locations[0][1] == locations[2][1]) {
			y = locations[1][1];
		} else if (locations[1][1] == locations[2][1]) {
			y = locations[0][1];
		}
		
		bw.write("" + x + " " + y);
		bw.flush();
		bw.close();
		
		br.close();
	}
	
}//class



































































21.12.21.11회차
===============================================================================
*단계별로 풀어보기 
===============================================================================




















































################################################################################################################
예제37)단계별로 풀어보기 / 기본수학2 / 직각삼각형

https://www.acmicpc.net/problem/4153
################################################################################################################


답 : 

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	
	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	public static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	public static final int LENGTH_COUNT = 3;
	
	public static void main(String[] args) throws IOException {	
		while (true) {
			int[] array = new int[LENGTH_COUNT];
			inputData(array);
			if (array[2] == 0) {
				break;
			}
			
			checkRight(array);
		}
		
		bw.flush();
		bw.close();
		
		br.close();
	}
	
	public static void inputData(int[] array) throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		for (int i = 0; i < 3; i++) {
			array[i] = Integer.parseInt(st.nextToken());
		}
		Arrays.sort(array);
	}
	
	public static void checkRight(int[] array) throws IOException {
		int test = (array[0] * array[0]) + (array[1] * array[1]); 
		int compare = (array[2] * array[2]);
		
		if (test == compare) {
			bw.write("right");
			bw.newLine();
			return;
		} 
		
		bw.write("wrong");
		bw.newLine();
	}
	
}//class






################################################################################################################
예제38)단계별로 풀어보기 / 기본수학2 / 택시 기하학(멘허튼거리)

*유클리드 기하학과 택시기하학의 거리기준을 알아야한다
	-유클리드는 대각선 최단거리 기준이고 택시기하학은 새로운 거리개념을 창안한 것이다.
	-그래서 원의 개념은 같지만 형태는 다르다.

https://www.acmicpc.net/problem/3053
################################################################################################################


답 : 


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	
	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	public static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	public static final int LENGTH_COUNT = 3;
	
	public static void main(String[] args) throws IOException {	
		
		int r = Integer.parseInt(br.readLine());
		
		double areaOfEuclid = Math.PI * r * r;
		double areaOfTaxi = 2 * r * r;
		
		bw.write(String.valueOf(areaOfEuclid));
		bw.newLine();
		bw.write(String.valueOf(areaOfTaxi));
		bw.newLine();
		
		bw.flush();
		bw.close();
		
		br.close();
	}
	
	
}//class









################################################################################################################
예제39)단계별로 풀어보기 / 기본수학2 / 터렛

*무한대인경우가 제일앞에 안나오면 -1이 아닌 1이 출력됨
	-이유는 무한대인 경우가 내접의 경우에 포함되기때문임 ㄷㄷ;
*double로 == 비교가 들어가는 경우 부동소수의 오차가 발생하여 문제 틀린걸로 됨 ㄷㄷ; 다 int로 바꿔서 할것

https://www.acmicpc.net/problem/1002

참고!
https://st-lab.tistory.com/90	-전체적으로 선이나 색깔이 잘칠해져있지면 2개의 경우 도식이 없음
https://nahwasa.com/58		-이게 좌표수 2개의 경우(접점 2개)까지 설명함
					-여기서 케이스 1개를 더 보여줌(AB가 동일한 위치이고 반지름이 다른 경우)
################################################################################################################


답 : 




접점이 없는 경우: 
	-AB가 동일하지 않은 위치
		-너무 멀리있는 경우 : (x2 - x1)^2 + (y2 - y1)^2 > (r2 + r1)^2
		-안에 있지만 반지름이 짧은 경우 : (x2 - x1)^2 + (y2 - y1)^2 < (r2 - r1)^2
	-AB가 동일한 위치이고 둘의 r이 다른 경우 : x1 = x2, y1 = y2, r2 != r1

접점이 1개인 경우:
	-내접 : (x2 - x1)^2 + (y2 - y1)^2 = (r2 - r1)^2 // (r1 - r2)^2 같음 왜냐면 루트넘기면 절대값처리하니까
							// 다만 B - A 형태를 취하고 있으니 r2 - r1을 적은 것 뿐(통일목적)
		-> ((x2 - x1)^2 + (y2 - y1)^2)^(1/2) = |r2 - r1|
	-외접 : (x2 - x1)^2 + (y2 - y1)^2 = (r2 + r1)^2

접점이 2개인 경우: (x2 - x1)^2 + (y2 - y1)^2 < (r2 + r1)^2

접점이 무한대인 경우: x1 = x2, y1 = y2, r1 = r2
	-두 원의 중심이 같고 반지름이 같을때




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	public static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	public static int x1;
	public static int y1;
	public static int r1;
	public static int x2;
	public static int y2;
	public static int r2;
	
	public static void main(String[] args) throws IOException {	
		int T = Integer.parseInt(br.readLine());
		for (int i = 0; i < T; i++) {
			int count = calcLocationCount();
			putBuffer(count);
		}
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static int calcLocationCount() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		x1 = Integer.parseInt(st.nextToken()); 
		y1 = Integer.parseInt(st.nextToken()); 
		r1 = Integer.parseInt(st.nextToken()); 
		x2 = Integer.parseInt(st.nextToken()); 
		y2 = Integer.parseInt(st.nextToken()); 
		r2 = Integer.parseInt(st.nextToken()); 
		
		int count = checkCircleShape(); 
		return count;
	}
	
	private static int checkCircleShape() { // 두 지점을 원으로 만들었을때의 모양을 확인한 후 모양에 따른 갯수를 반환하는 메서드
		int distance =  (int) (Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
		int subtract = (int) Math.pow(r2 - r1, 2);
		int add = (int) Math.pow(r1 + r2, 2);

		// 무한대인 경우			
		if (distance == 0 && r1 == r2) {
			return -1;
		}
		
		// 0개인 경우
		if (distance < subtract || distance > add) {
			return 0;
		}
		
		/* 해당 경우는 위 조건의 첫번째 경우에 속함으로 주석가능. 혹여나 위의  r1,r2에 관련된
		 * 값을 절대값 처리 안한다면 반드시 해당 경우 주석풀어서 입력되어야함.
		 *	if (x1 == x2 && y1 == y2 && r1 != r2) {
		 * 
		 *		return 0;
		 *	}
		 */
				
		// 1개인 경우
		if (distance == subtract || distance == add) {
			return 1;
		}
		
		// 2개인 경우
		if (distance < add) {
			return 2;
		}
		
		
		return -5; // 의미없는 값
	}
	
	public static void putBuffer(int count) throws IOException {
		bw.write(String.valueOf(count));
		bw.newLine();
	}
}//class
































































21.12.22.12회차
===============================================================================
*단계별로 풀어보기 
===============================================================================










































################################################################################################################
예제40)단계별로 풀어보기 / 재귀 / 팩토리얼

https://www.acmicpc.net/problem/10872
################################################################################################################


답 : 

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	public static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {	
		int N = Integer.parseInt(br.readLine());
		int result = calcFactorial(N);
		bw.write(String.valueOf(result));
		bw.newLine();
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static int calcFactorial(int N) {
		if (N == 0) {
			return 1;
		}
		if (N == 1) {
			return 1;
		}
		return N * calcFactorial(N-1);
	}

}//class
















################################################################################################################
예제41)단계별로 풀어보기 / 재귀 / 피보나치 수 5


https://www.acmicpc.net/problem/10870
################################################################################################################


답 : 



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	public static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {	
		int n = Integer.parseInt(br.readLine());
		int result = calcFibonacci(n);
		
		bw.write(String.valueOf(result));
		bw.newLine();
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static int calcFibonacci(int n) {
		if (n == 0) {
			return 0;
		}
		if (n == 1) {
			return 1;
		}
		if (n == 2) {
			return 1;
		}
		
		return calcFibonacci(n - 2) + calcFibonacci(n - 1);
	}

}//class












날 안아 주세요~~~~~
불빛 처럼~~
가까이~ (가까이~) 다가와(다가와~) 함께 있을래요오~ 
날안아 주세요~~ 후우와아아아






################################################################################################################
예제42)단계별로 풀어보기 / 재귀 / 별 찍기 - 10

*StringBuilder를 이용해서 bw.write()를 한번만 사용하여 출력도 한번만 하라
	-까먹지 않게 연습

https://www.acmicpc.net/problem/2447
################################################################################################################


답 : 


  0 1 2 3 4 5 6 7 8
0 * * * * * * * * *
1 *   * *   * *   *
2 * * * * * * * * *
3 * * *       * * *
4 *   *       *   *
5 * * *       * * *
6 * * * * * * * * *             
7 *   * *   * *   *
8 * * * * * * * * *



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;
import java.util.StringTokenizer;

public class Main {	
	public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	public static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static char[][] arr;

	
	public static void main(String[] args) throws IOException {	
		int n = Integer.parseInt(br.readLine());
		StringBuilder sb = new StringBuilder();
		
		arr = new char[n][n];
		putStar(0, 0, n, false);
		
		for (int i = 0; i < n; i++) {
			for (int j = 0; j < n; j++) {
				sb.append(arr[i][j]);
			}
			sb.append("\n");
		}
		
		bw.write(sb.toString());
		bw.newLine();
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void putStar(int x, int y, int n, boolean blank) {
		
		if (blank) {
			for (int i = x; i < x + n; i++) {
				for (int j = y; j < y + n; j++) {
					arr[i][j] = ' ';
				}
			}
			
			return;
		}
		
		if (n == 1) {
			arr[x][y] = '*';
			return;
		}
		
		int size = n / 3;
		int count = 0;
		
		for (int i = x; i < x + n; i += size) {
			for (int j = y; j < y + n; j += size) {
				count++;
				
				if (count == 5) {
					putStar(i, j, size, true);
				} else {
					putStar(i, j, size, false);
				}
			}
		}
	
	}


	 
	 
	 
}//class

21.12.31.17회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================





################################################################################################################
예제1)알고리즘 기초 1 / 자료구조1 / 스택

https://www.acmicpc.net/problem/10828
################################################################################################################


답 : 




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		Stack stack = new Stack();
		
		
		inputData(stack, N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void inputData(Stack stack, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			String[] str = br.readLine().split(" ");
			if (str.length == 2) {
				stack.push(Integer.parseInt(str[1]));
			} else {
				String tmp = str[0];
				if (tmp.equals("pop")) {
					if (stack.empty()) {
						bw.write("" + (-1));
						bw.newLine();
						continue;
					}
					bw.write("" + stack.pop());
					bw.newLine();
					continue;
				}
				if (tmp.equals("size")) {
					bw.write("" + stack.size());
					bw.newLine();
					continue;
				}
				if (tmp.equals("empty")) {
					if (stack.empty()) {
						bw.write("1");
						bw.newLine();
						continue;
					} 
					bw.write("0");
					bw.newLine();
					continue;
				}
				if (tmp.equals("top")) {
					if (stack.empty()) {
						bw.write("" + (-1));
						bw.newLine();
						continue;
					}				
					bw.write("" + stack.peek());
					bw.newLine();
				}
			}
		}
	}

}//class








################################################################################################################
예제2)알고리즘 기초 1 / 자료구조1 / 단어 뒤집기

https://www.acmicpc.net/problem/9093
################################################################################################################


답 : 




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		Stack stack = new Stack();
		
		inputData(stack, N);
		
		bw.close();
		br.close();
	}
	
	public static void inputData(Stack stack, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			String[] str = br.readLine().split(" ");
			inputData(stack, str, str.length);
		}
	}
	
	private static void inputData(Stack stack, String[] str, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			reverseThroughStack(stack, str[i], str[i].length());
		}
		
		bw.newLine();
		bw.flush();
	}
	
	private static void reverseThroughStack(Stack stack, String str, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			stack.push(str.charAt(i));
		}
		
		writeData(stack, N);
	}
	
	private static void writeData(Stack stack, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			bw.write(String.valueOf(stack.pop()));			
		}
		
		bw.write(" ");
	}

}//class








################################################################################################################
예제3)알고리즘 기초 1 / 자료구조1 / 괄호

https://www.acmicpc.net/problem/9012
################################################################################################################


답 : 



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());

		String[] arr = new String[N];
		
		inputData(arr, N);
		checkVPS(arr, N);
		
		bw.close();
		br.close();
	}
	
	public static void inputData(String[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			arr[i] = br.readLine();
		}
	}
	
	public static void checkVPS(String[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			Stack stack = new Stack();
			pushStack(arr[i], arr[i].length(), stack);
			boolean flag = isVPS(stack);
			writeData(flag);
		}
	}
	
	private static void pushStack(String str, int N, Stack stack) {
		for (int i = 0; i < N; i++) {
			stack.push(str.charAt(i));
		}
	}
	
	private static boolean isVPS(Stack stack) {
		if ((char) stack.peek() == '(' || stack.size() % 2 != 0) {
			return false;
		}
		
		int count = 0;
		while (!stack.empty()) {	
			while (!stack.empty() && (char) stack.peek() == ')') {
				stack.pop();
				count++;
			}
			
			while (!stack.empty() && (char) stack.peek() == '(') {
				stack.pop();
				count--;
				
				if (count == -1) {
					return false;
				}
			}
		}
		
		if (count != 0) {
			return false;
		}
		
		return true;
	}
	
	private static void writeData(boolean flag) throws IOException {
		if (flag) {
			bw.write("YES\n");
			return;
		}
		
		if (!flag) {
			bw.write("NO\n");
		}
	}
}//class





다른사람답(while안쓰고 for문사용, 새로운 char배열만들어서 앞에서부터 확인하여 빼가는데 count가 -1인경우는
	stac.isEmpty()를 활용해서 확인하고 삭제하는 방식. stack에 값이 다들어가지 않아도 된다는 면에서는
	효율적이지만 내 방식은 char배열을 안만든다는 점에서 메모리소비를 막을수 있음)




import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class Main {

	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int T = Integer.parseInt(br.readLine());
		for(int tc=1;tc<=T;tc++) {
			String str = br.readLine();
			char[] arr =str.toCharArray();
			
			Stack<Character> stack = new Stack<>();
			boolean flag = true;
			for(char c:arr) {
				if(c=='(') {
					stack.push(c);
				}else {
					if(stack.isEmpty()) {
						flag=false;
						break;
					}
					stack.pop();						
				}
			}
			
			if(!stack.isEmpty()) {
				flag=false;
			}
			if(!flag) {
				System.out.println("NO");
			}else {
				System.out.println("YES");
			}
		}
		
	}

}










################################################################################################################
예제4)알고리즘 기초 1 / 자료구조1 / 스택 수열

https://www.acmicpc.net/problem/1874
################################################################################################################



인터넷에 더 간결하고 직관적인 코드:
package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		int[] arr = new int[N];
				
		inputData(arr, N);
		makeBunch(arr, N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void inputData(int[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			arr[i] = Integer.parseInt(br.readLine());
		}
	}
	
	public static void makeBunch(int[] arr, int N) throws IOException {
		int j = 1;
		for (int i = 0; i < N; i++) {
			// j > arr[i] 라면 절대 stack이 비어 있을 수 없다.
				// 현재 j 전까지는 모두 스택에 push되었기 때문
			if (stack.empty() || (int) stack.peek() < arr[i]) {
				while (j <= arr[i]) {
					stack.push(j);
					sb.append("+\n");
					j++;
				}
				
				stack.pop();
				sb.append("-\n");
			} else if ((int) stack.peek() == arr[i]) {
				stack.pop();
				sb.append("-\n");
			} else if ((int) stack.peek() > arr[i]) {
				bw.write("NO");
				return;
			}
		}
		
		bw.write(sb.toString());
	}
}//class






처음 내가 낸 답 : 


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		int[] arr = new int[N];
		
	
		
		inputData(arr, N);
		makeBunch(arr, N);
		
		br.close();
	}
	
	public static void inputData(int[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			arr[i] = Integer.parseInt(br.readLine());
		}
	}
	
	public static void makeBunch(int[] arr, int N) throws IOException {
		int j = 1;
		for (int i = 0; i < N; i++) {
			while (true) {
				if (arr[i] > j) {
					stack.push(j);
					sb.append("+\n");
					j++;		
					continue;
				}
				
				if (arr[i] == j) {
					stack.push(j);
					sb.append("+\n");
					stack.pop();
					sb.append("-\n");
					j++;
				
					while (!stack.empty() && i + 1 < N && arr[i + 1] == (int) stack.peek()) {
						stack.pop();
						sb.append("-\n");
						i++;
					}
							
					break;
				}

				if (!stack.empty() && arr[i] < (int) stack.peek()) {
					System.out.println("NO");
					return;
				}
			}
		}
		
//		if (!stack.empty()) {
//			System.out.println("NO");
//			return;
//		}
		
		System.out.println(sb.toString());
	}
}//class



























































































21.1.1.18회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================





























































































################################################################################################################
예제5)알고리즘 기초 1 / 자료구조1 / 에디터

https://www.acmicpc.net/problem/1406
################################################################################################################




답(else가 없게 가시적으로 편하게 정리한 코드):

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack1 = new Stack();
	private static Stack stack2 = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = 0;
		String str = "";
		N = inputData(str);
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static int inputData(String str) throws IOException {
		str = br.readLine();
		int N = Integer.parseInt(br.readLine());
		inputStack(str);
		
		for (int i = 0; i < N; i++) {
			action(str);
		}
		
		workFinish(str);
		
		return N;
	}
	
	private static void inputStack(String str) {
		for (int i = 0; i < str.length(); i++) {
			stack1.push(str.charAt(i));
		}	
	}
	
	private static void action(String str) throws IOException {
		String[] order = br.readLine().split(" ");

		if (order.length == 1) {
			if (order[0].charAt(0) == 'L') {
				if (stack1.empty()) {
					return;
				}
				
				stack2.push(stack1.pop());
				return;
			}
		
			if (order[0].charAt(0) == 'D') {
				if (stack2.empty()) {
					return;
				}
				
				stack1.push(stack2.pop());
				return;
			} 
			
			
			{ // order[0].charAt(0) == 'B'인 경우
				if (stack1.empty()) {
					return;
				}
				
				stack1.pop();
				return;
			}
		} 
		
		// order.length == 2인 경우
		stack1.push(order[1].charAt(0));
	}
	
	
	private static void workFinish(String str) throws IOException {
		if (!stack2.empty()) {
			finishStack1();
		}

		finishStringBuilder();
	}
	
	private static void finishStack1() {
		int len = stack2.size();
		for (int i = 0; i < len; i++) {
			stack1.push(stack2.pop());
		}
	}
	
	private static void finishStringBuilder() throws IOException {
		for (int i = 0; i < stack1.size(); i++) {
			sb.append(stack1.get(i));
		}
		
		bw.write(sb.toString());
	}
	

}//class



답(else가 있지만 속도는 쬐끔 더 빠른 코드):



import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack1 = new Stack();
	private static Stack stack2 = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = 0;
		String str = "";
		N = inputData(str);
		
		br.close();
	}
	
	public static int inputData(String str) throws IOException {
		str = br.readLine();
		int N = Integer.parseInt(br.readLine());
		inputStack(str);
		
		for (int i = 0; i < N; i++) {
			action(str);
		}
		
		workFinish(str);
		
		return N;
	}
	
	private static void inputStack(String str) {
		for (int i = 0; i < str.length(); i++) {
			stack1.push(str.charAt(i));
		}	
	}
	
	private static void action(String str) throws IOException {
		String[] order = br.readLine().split(" ");

		if (order.length == 1) {
			
			
			if (order[0].charAt(0) == 'L') {
				if (stack1.empty()) {
					return;
				}
				stack2.push(stack1.pop());
			} else if (order[0].charAt(0) == 'D') {
				if (stack2.empty()) {
					return;
				}
				stack1.push(stack2.pop());
			} else if (order[0].charAt(0) == 'B') {
				if (stack1.empty()) {
					return;
				}
				stack1.pop();
			}
		} else if (order.length == 2) {
			stack1.push(order[1].charAt(0));
		}
	}
	
	
	private static void workFinish(String str) {
		if (!stack2.empty()) {
			finishStack1();
		}

		finishStringBuilder();
	}
	
	private static void finishStack1() {
		int len = stack2.size();
		for (int i = 0; i < len; i++) {
			stack1.push(stack2.pop());
		}
	}
	
	private static void finishStringBuilder() {
		for (int i = 0; i < stack1.size(); i++) {
			sb.append(stack1.get(i));
		}
		
		System.out.println(sb.toString());
	}
	

}//class


















################################################################################################################
예제6)알고리즘 기초 1 / 자료구조1 / 큐

*dequeue(덱) 문제가 아니다. queue로만 해겶해라. back을 효율적으로 항상 back할때마다
	조건연산 확인하는것이아니라 특정 값이 바뀌는 곳에서만 연산하도록 헤아려라

https://www.acmicpc.net/problem/10845
################################################################################################################


답:




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Queue<Integer> que = new LinkedList<>();
	private static int back = -1;
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		getData(N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	private static void getData(int N) throws IOException {
		for (int i = 0; i < N; i++) {
			int result = receiveOrder();
			if (result != -2) { // push를 상징하는 수가 반환된 경우 출력하지 말라는 의미
				sb.append(result).append("\n");				
			}
		}
		
		bw.write(sb.toString());
	}

	private static int receiveOrder() throws IOException {
		String[] str = br.readLine().split(" ");

		
		if (str.length == 2) {
			back = Integer.parseInt(str[1]);
			que.offer(back);
			return -2; // push인 경우 출력하지 말라는 의미의 수 반환
		}
		
		{ // str.length == 1 인 경우
			if (str[0].equals("front")) {
				if (que.isEmpty()) {
					return -1;
				}
				
				return que.peek();			
			}

			if (str[0].equals("back")) {
				return back;
			}
			
			if (str[0].equals("pop")) {
				if (que.isEmpty()) {
					return -1;
				}
				
				int tmp = que.poll();
				
				if (que.isEmpty()) {
					back = -1;
				}
				
				return tmp;
			}
			
			if (str[0].equals("size")) {
				return que.size();
			}
			
			if (str[0].equals("empty")) {
				if (que.isEmpty()) {
					return 1;
				}
				
				return 0;
			}
			
		}
		
		return Integer.MAX_VALUE; // 해당 수가 출력될 일은 없음
	}
}//class















################################################################################################################
예제7)알고리즘 기초 1 / 자료구조1 / 조세퍼스 문제

*최대한 효율적이게 해라. 아래 답은 여러가지 방법을 제시한다.
*큐로 풀어라 디큐(덱)금지

https://www.acmicpc.net/problem/1158
################################################################################################################



답:



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Queue<Integer> que = new LinkedList<>();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		int[] N = new int[2];
		N[0] = Integer.parseInt(st.nextToken());
		N[1] = Integer.parseInt(st.nextToken());
				
		inputQueue(N[0]);
		
		sb.append("<");
		makeJosephus(N);
		sb.append(">");
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void inputQueue(int N) {
		for (int i = 1; i <= N; i++) {
			que.offer(i);
		}
	}
	
	public static void makeJosephus(int[] N) {
		while (!que.isEmpty()) { // 실험결과 지금처럼보다는 테두리를 아래 for로 하고 내부 내용물을 넣었을때가 더 빠르네 
			for (int j = 1; j < N[1]; j++) {
				que.offer(que.poll());
			}
			
			sb.append(que.poll()).append(", ");			
		}
//		for (int i = 0; i < N[0]; i++) {
//			for (int j = 0; j < N[1]; j++) {
//				if (j == N[1] - 1) {
//					if (i == N[0] - 1) {
//						sb.append(que.poll());
//						break;
//					}
//					sb.append(que.poll()).append(", ");
//					break;
//				}
//				
//				que.offer(que.poll());
//			}
			
//			int count = 0;
//			while (true) {
//				count++;
//				if (count % N[1] == 0) {
//					if (i == N[0] - 1) {
//						sb.append(que.poll());
//						break;
//					}
//					sb.append(que.poll()).append(", ");
//					break;
//				}
//				que.offer(que.poll());				
//			}
//		}
		
		sb.setLength(sb.length() - 2);
	}
}//class


















################################################################################################################
예제8)알고리즘 기초 1 / 자료구조1 / 덱

https://www.acmicpc.net/problem/10866
################################################################################################################

답:


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Integer> deque = new ArrayDeque<>();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		int N = Integer.parseInt(br.readLine());
		
		getOrder(N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void getOrder(int N) throws IOException {
		for (int i = 0; i < N; i++) {
			int result = runOrder();
			
			if (result != -2) {
				bw.write(String.valueOf(result));
				bw.newLine();
			}
		}
	}
	
	private static int runOrder() throws IOException {
		String[] str = br.readLine().split(" ");
		
		if (str.length == 2) { // que에 입력하는 명령
			if (str[0].equals("push_front")) {
				deque.offerFirst(Integer.parseInt(str[1]));
				return -2;
			}
			if (str[0].equals("push_back")) {
				deque.offerLast(Integer.parseInt(str[1]));
				return -2;
			}
		}
		
		{ // str.length == 1 인 경우
			{ // 삭제 및 출력하는 명령
				if (str[0].equals("pop_front")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.pollFirst();
				}
				if (str[0].equals("pop_back")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.pollLast();
				}				
			}
			{ // 출력민하는 명령
				if (str[0].equals("front")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.peekFirst();
				}
				if (str[0].equals("back")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.peekLast();
				}
			}
			{ // 그밖의 기타 명령
				if (str[0].equals("size")) {
					return deque.size();
				}
				if (str[0].equals("empty")) {
					if (deque.isEmpty()) {
						return 1;
					}
					return 0;
				}
			}
		}
		
		return Integer.MAX_VALUE;
	}
}//class
















































































21.01.03.19회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================





































































	
################################################################################################################
예제9)알고리즘 기초 1 / 자료구조 1 (연습) / 단어 뒤집기 2

*deque를 응용해서 풀어라
	-응용한경우 : 296ms
	-응용 안한경우 : 1708ms

https://www.acmicpc.net/problem/17413
################################################################################################################


답(deque를 효율적으로 이용하여 que와 stack을 동시에 사용하기):
	-단어를 나누지 않음. stack, que 두개를 선언한 다른사람의 방식을 응용한것
	-논리적으로는 단어를 나누는게 더 가독성이 좋지 않나 싶지만 극명한 시간차이.. deque를
		잘 이용하자.. 

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Character> deque = new ArrayDeque<>();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		String str = inputData();
		reverseThrowDeque(str);
		bw.write(sb.toString());
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static String inputData() throws IOException {
		String str = br.readLine();
		return str;
	}

	public static void reverseThrowDeque(String str) {
		str += " ";
		boolean flag = true;
		
		for (int i = 0; i < str.length(); i++) {
			if (str.charAt(i) == '<') {
				if (!deque.isEmpty()) {
					while (!deque.isEmpty()) {
						sb.append(deque.pollLast());
					}
				}
				
				sb.append("<");
				flag = false;
			} else if (str.charAt(i) == '>') {
				while (!deque.isEmpty()) {
					sb.append(deque.pollFirst());
				}
				
				sb.append(">");
				flag = true;
			} else if (str.charAt(i) == ' ') {
				if (flag) {
					while (!deque.isEmpty()) {
						sb.append(deque.pollLast());
					}
				} else {
					while (!deque.isEmpty()) {
						sb.append(deque.pollFirst());
					}
				}
				
				sb.append(" ");	
			} else {
				deque.offerLast(str.charAt(i));
			}
		}
	}
}//class





답(단어와 태그를 먼저 구분한뒤 스택만을 이용하여 출력하는 방식):
	-처음 푼 방법, bunch가 있음. 단어와 태그를 구분한뒤 집어넣어야하니까.

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Character> deque = new ArrayDeque<>();
	private static StringBuilder sb = new StringBuilder();
	private static String[] bunch = new String[100000];
	
	public static void main(String[] args) throws IOException {
		
		String str = inputData();
		int count = cutStr(str);
		reverseThrowDeque(count);
		bw.write(sb.toString());
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static String inputData() throws IOException {
		String str = br.readLine();
		return str;
	}
	
	public static int cutStr(String str) {
		int count = 0;
		String tmp = "";

		for (int i = 0; i < str.length(); i++) {
			
			char ch = str.charAt(i);
			if (ch == '<') {
				if (tmp.length() > 0) {
					bunch[count] = tmp;
					count++;
					tmp = "";
				}
				
				while (str.charAt(i) != '>') {
					tmp += str.charAt(i);
					i++;
				}
				tmp += str.charAt(i);
				bunch[count] = tmp;
				count++;
				tmp = "";
				continue;
			}
			
			if (ch == ' ') {
				bunch[count] = tmp;
				count++;
				tmp = "";
				continue;
			}
			
			if (i == str.length() - 1) {
				tmp += str.charAt(i);
				bunch[count] = tmp;
				count++;
				tmp = "";
				continue;
			}
			tmp += str.charAt(i);
		}
		
		return count;
	}
	
	public static void reverseThrowDeque(int count) {
		for (int i = 0; i < count; i++) {
			String tmp = reverseWord(bunch[i]);
			
			if (tmp.charAt(0) == '<') {
				if (sb.length() != 0 && sb.charAt(sb.length() - 1) != '>') {
					sb.setLength(sb.length() - 1);					
				}
				sb.append(tmp);
				continue;
			}
			
			sb.append(tmp).append(' ');
		}
	}
	
	private static String reverseWord(String tmp) {
		if (tmp.charAt(0) == '<') {
			return tmp;
		}
		
		int len = tmp.length();
		for (int i = 0; i < len; i++) {
			deque.offerLast(tmp.charAt(i));
		}
		
		tmp = "";
		for (int i = 0; i < len; i++) {
			tmp += deque.pollLast();
		}
		
		return tmp;
	}
	
}//class




















################################################################################################################
예제10)알고리즘 기초 1 / 자료구조 1 (연습) / 쇠막대기

https://www.acmicpc.net/problem/10799
################################################################################################################


답:



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Character> deque = new ArrayDeque<>();
	private static Stack<Character> stack = new Stack<>();
	private static StringBuilder sb = new StringBuilder();

	private static int separationCount = 0;
	private static int barCount = 0;
	
	public static void main(String[] args) throws IOException {
		String str = inputData();
		inputDeque(str);
		calc();
		lastCalcOfSeparationCount();

		bw.write(String.valueOf(separationCount));
		bw.flush();
		bw.close();
		br.close();
	}

	public static String inputData() throws IOException {
		return br.readLine();
	}
	
//	public static void getTotalCountOfBar() { barCount때매 필요없어진 함수
//		int count = 0;
//		
//		while (!deque.isEmpty()) {
//			int top = deque.pollFirst();
//			
//			if (top == '(' && top == deque.peekFirst()) {
//				count++;
//			}
//		}
//		
//		separationCount = count;
//	}
	
	public static void inputDeque(String str) {
		for (int i = 0; i < str.length(); i++) {
			deque.offerLast(str.charAt(i));
		}
	}
	
	public static void calc() {
		int separationCount = 0;
		
		while (!deque.isEmpty()) {
			char top = deque.pollFirst();
			
			if (top == '('
					&& deque.peekFirst() == ')') { // 레이저인 경우
				int laserCount = 0;
				
				deque.pollFirst();
				laserCount++;
				while ((top = deque.pollFirst()) == '(' 
						&& deque.peekFirst() == ')') {
					deque.pollFirst();
					laserCount++;
				}
				
				deque.offerFirst(top);
				
				checkSeparation(laserCount);
				continue;
			}
			
			{ // top == deque.peekFirst() 레이저가 아닌 경우				
				if (top == '(') { // 쇠막대 하나가 시작된 경우
					stack.push(top);
					barCount++;
					continue;
				}

				if (top == ')'){ // 쇠막대 하나가 끝난 경우
					stack.pop();
					continue;
				}
			}
			
		}
	}
	
	private static void checkSeparation(int laserCount) {
		int exposedCount = stack.size();
		separationCount += exposedCount * laserCount;
	}
	
	private static void lastCalcOfSeparationCount() {
		separationCount += barCount;
	}
}//class

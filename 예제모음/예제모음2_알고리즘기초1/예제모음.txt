21.12.31.17회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================





################################################################################################################
예제1)알고리즘 기초 1 / 자료구조1 / 스택

https://www.acmicpc.net/problem/10828
################################################################################################################


답 : 




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		Stack stack = new Stack();
		
		
		inputData(stack, N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void inputData(Stack stack, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			String[] str = br.readLine().split(" ");
			if (str.length == 2) {
				stack.push(Integer.parseInt(str[1]));
			} else {
				String tmp = str[0];
				if (tmp.equals("pop")) {
					if (stack.empty()) {
						bw.write("" + (-1));
						bw.newLine();
						continue;
					}
					bw.write("" + stack.pop());
					bw.newLine();
					continue;
				}
				if (tmp.equals("size")) {
					bw.write("" + stack.size());
					bw.newLine();
					continue;
				}
				if (tmp.equals("empty")) {
					if (stack.empty()) {
						bw.write("1");
						bw.newLine();
						continue;
					} 
					bw.write("0");
					bw.newLine();
					continue;
				}
				if (tmp.equals("top")) {
					if (stack.empty()) {
						bw.write("" + (-1));
						bw.newLine();
						continue;
					}				
					bw.write("" + stack.peek());
					bw.newLine();
				}
			}
		}
	}

}//class








################################################################################################################
예제2)알고리즘 기초 1 / 자료구조1 / 단어 뒤집기

https://www.acmicpc.net/problem/9093
################################################################################################################


답 : 




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		Stack stack = new Stack();
		
		inputData(stack, N);
		
		bw.close();
		br.close();
	}
	
	public static void inputData(Stack stack, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			String[] str = br.readLine().split(" ");
			inputData(stack, str, str.length);
		}
	}
	
	private static void inputData(Stack stack, String[] str, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			reverseThroughStack(stack, str[i], str[i].length());
		}
		
		bw.newLine();
		bw.flush();
	}
	
	private static void reverseThroughStack(Stack stack, String str, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			stack.push(str.charAt(i));
		}
		
		writeData(stack, N);
	}
	
	private static void writeData(Stack stack, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			bw.write(String.valueOf(stack.pop()));			
		}
		
		bw.write(" ");
	}

}//class








################################################################################################################
예제3)알고리즘 기초 1 / 자료구조1 / 괄호

https://www.acmicpc.net/problem/9012
################################################################################################################


답 : 



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());

		String[] arr = new String[N];
		
		inputData(arr, N);
		checkVPS(arr, N);
		
		bw.close();
		br.close();
	}
	
	public static void inputData(String[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			arr[i] = br.readLine();
		}
	}
	
	public static void checkVPS(String[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			Stack stack = new Stack();
			pushStack(arr[i], arr[i].length(), stack);
			boolean flag = isVPS(stack);
			writeData(flag);
		}
	}
	
	private static void pushStack(String str, int N, Stack stack) {
		for (int i = 0; i < N; i++) {
			stack.push(str.charAt(i));
		}
	}
	
	private static boolean isVPS(Stack stack) {
		if ((char) stack.peek() == '(' || stack.size() % 2 != 0) {
			return false;
		}
		
		int count = 0;
		while (!stack.empty()) {	
			while (!stack.empty() && (char) stack.peek() == ')') {
				stack.pop();
				count++;
			}
			
			while (!stack.empty() && (char) stack.peek() == '(') {
				stack.pop();
				count--;
				
				if (count == -1) {
					return false;
				}
			}
		}
		
		if (count != 0) {
			return false;
		}
		
		return true;
	}
	
	private static void writeData(boolean flag) throws IOException {
		if (flag) {
			bw.write("YES\n");
			return;
		}
		
		if (!flag) {
			bw.write("NO\n");
		}
	}
}//class





다른사람답(while안쓰고 for문사용, 새로운 char배열만들어서 앞에서부터 확인하여 빼가는데 count가 -1인경우는
	stac.isEmpty()를 활용해서 확인하고 삭제하는 방식. stack에 값이 다들어가지 않아도 된다는 면에서는
	효율적이지만 내 방식은 char배열을 안만든다는 점에서 메모리소비를 막을수 있음)




import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class Main {

	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int T = Integer.parseInt(br.readLine());
		for(int tc=1;tc<=T;tc++) {
			String str = br.readLine();
			char[] arr =str.toCharArray();
			
			Stack<Character> stack = new Stack<>();
			boolean flag = true;
			for(char c:arr) {
				if(c=='(') {
					stack.push(c);
				}else {
					if(stack.isEmpty()) {
						flag=false;
						break;
					}
					stack.pop();						
				}
			}
			
			if(!stack.isEmpty()) {
				flag=false;
			}
			if(!flag) {
				System.out.println("NO");
			}else {
				System.out.println("YES");
			}
		}
		
	}

}










################################################################################################################
예제4)알고리즘 기초 1 / 자료구조1 / 스택 수열

https://www.acmicpc.net/problem/1874
################################################################################################################



인터넷에 더 간결하고 직관적인 코드:
package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		int[] arr = new int[N];
				
		inputData(arr, N);
		makeBunch(arr, N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void inputData(int[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			arr[i] = Integer.parseInt(br.readLine());
		}
	}
	
	public static void makeBunch(int[] arr, int N) throws IOException {
		int j = 1;
		for (int i = 0; i < N; i++) {
			// j > arr[i] 라면 절대 stack이 비어 있을 수 없다.
				// 현재 j 전까지는 모두 스택에 push되었기 때문
			if (stack.empty() || (int) stack.peek() < arr[i]) {
				while (j <= arr[i]) {
					stack.push(j);
					sb.append("+\n");
					j++;
				}
				
				stack.pop();
				sb.append("-\n");
			} else if ((int) stack.peek() == arr[i]) {
				stack.pop();
				sb.append("-\n");
			} else if ((int) stack.peek() > arr[i]) {
				bw.write("NO");
				return;
			}
		}
		
		bw.write(sb.toString());
	}
}//class






처음 내가 낸 답 : 


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		int[] arr = new int[N];
		
	
		
		inputData(arr, N);
		makeBunch(arr, N);
		
		br.close();
	}
	
	public static void inputData(int[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			arr[i] = Integer.parseInt(br.readLine());
		}
	}
	
	public static void makeBunch(int[] arr, int N) throws IOException {
		int j = 1;
		for (int i = 0; i < N; i++) {
			while (true) {
				if (arr[i] > j) {
					stack.push(j);
					sb.append("+\n");
					j++;		
					continue;
				}
				
				if (arr[i] == j) {
					stack.push(j);
					sb.append("+\n");
					stack.pop();
					sb.append("-\n");
					j++;
				
					while (!stack.empty() && i + 1 < N && arr[i + 1] == (int) stack.peek()) {
						stack.pop();
						sb.append("-\n");
						i++;
					}
							
					break;
				}

				if (!stack.empty() && arr[i] < (int) stack.peek()) {
					System.out.println("NO");
					return;
				}
			}
		}
		
//		if (!stack.empty()) {
//			System.out.println("NO");
//			return;
//		}
		
		System.out.println(sb.toString());
	}
}//class



























































































21.1.1.18회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================





























































































################################################################################################################
예제5)알고리즘 기초 1 / 자료구조1 / 에디터

https://www.acmicpc.net/problem/1406
################################################################################################################




답(else가 없게 가시적으로 편하게 정리한 코드):

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack1 = new Stack();
	private static Stack stack2 = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = 0;
		String str = "";
		N = inputData(str);
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static int inputData(String str) throws IOException {
		str = br.readLine();
		int N = Integer.parseInt(br.readLine());
		inputStack(str);
		
		for (int i = 0; i < N; i++) {
			action(str);
		}
		
		workFinish(str);
		
		return N;
	}
	
	private static void inputStack(String str) {
		for (int i = 0; i < str.length(); i++) {
			stack1.push(str.charAt(i));
		}	
	}
	
	private static void action(String str) throws IOException {
		String[] order = br.readLine().split(" ");

		if (order.length == 1) {
			if (order[0].charAt(0) == 'L') {
				if (stack1.empty()) {
					return;
				}
				
				stack2.push(stack1.pop());
				return;
			}
		
			if (order[0].charAt(0) == 'D') {
				if (stack2.empty()) {
					return;
				}
				
				stack1.push(stack2.pop());
				return;
			} 
			
			
			{ // order[0].charAt(0) == 'B'인 경우
				if (stack1.empty()) {
					return;
				}
				
				stack1.pop();
				return;
			}
		} 
		
		// order.length == 2인 경우
		stack1.push(order[1].charAt(0));
	}
	
	
	private static void workFinish(String str) throws IOException {
		if (!stack2.empty()) {
			finishStack1();
		}

		finishStringBuilder();
	}
	
	private static void finishStack1() {
		int len = stack2.size();
		for (int i = 0; i < len; i++) {
			stack1.push(stack2.pop());
		}
	}
	
	private static void finishStringBuilder() throws IOException {
		for (int i = 0; i < stack1.size(); i++) {
			sb.append(stack1.get(i));
		}
		
		bw.write(sb.toString());
	}
	

}//class



답(else가 있지만 속도는 쬐끔 더 빠른 코드):



import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack1 = new Stack();
	private static Stack stack2 = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = 0;
		String str = "";
		N = inputData(str);
		
		br.close();
	}
	
	public static int inputData(String str) throws IOException {
		str = br.readLine();
		int N = Integer.parseInt(br.readLine());
		inputStack(str);
		
		for (int i = 0; i < N; i++) {
			action(str);
		}
		
		workFinish(str);
		
		return N;
	}
	
	private static void inputStack(String str) {
		for (int i = 0; i < str.length(); i++) {
			stack1.push(str.charAt(i));
		}	
	}
	
	private static void action(String str) throws IOException {
		String[] order = br.readLine().split(" ");

		if (order.length == 1) {
			
			
			if (order[0].charAt(0) == 'L') {
				if (stack1.empty()) {
					return;
				}
				stack2.push(stack1.pop());
			} else if (order[0].charAt(0) == 'D') {
				if (stack2.empty()) {
					return;
				}
				stack1.push(stack2.pop());
			} else if (order[0].charAt(0) == 'B') {
				if (stack1.empty()) {
					return;
				}
				stack1.pop();
			}
		} else if (order.length == 2) {
			stack1.push(order[1].charAt(0));
		}
	}
	
	
	private static void workFinish(String str) {
		if (!stack2.empty()) {
			finishStack1();
		}

		finishStringBuilder();
	}
	
	private static void finishStack1() {
		int len = stack2.size();
		for (int i = 0; i < len; i++) {
			stack1.push(stack2.pop());
		}
	}
	
	private static void finishStringBuilder() {
		for (int i = 0; i < stack1.size(); i++) {
			sb.append(stack1.get(i));
		}
		
		System.out.println(sb.toString());
	}
	

}//class


















################################################################################################################
예제6)알고리즘 기초 1 / 자료구조1 / 큐

*dequeue(덱) 문제가 아니다. queue로만 해겶해라. back을 효율적으로 항상 back할때마다
	조건연산 확인하는것이아니라 특정 값이 바뀌는 곳에서만 연산하도록 헤아려라

https://www.acmicpc.net/problem/10845
################################################################################################################


답:




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Queue<Integer> que = new LinkedList<>();
	private static int back = -1;
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		getData(N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	private static void getData(int N) throws IOException {
		for (int i = 0; i < N; i++) {
			int result = receiveOrder();
			if (result != -2) { // push를 상징하는 수가 반환된 경우 출력하지 말라는 의미
				sb.append(result).append("\n");				
			}
		}
		
		bw.write(sb.toString());
	}

	private static int receiveOrder() throws IOException {
		String[] str = br.readLine().split(" ");

		
		if (str.length == 2) {
			back = Integer.parseInt(str[1]);
			que.offer(back);
			return -2; // push인 경우 출력하지 말라는 의미의 수 반환
		}
		
		{ // str.length == 1 인 경우
			if (str[0].equals("front")) {
				if (que.isEmpty()) {
					return -1;
				}
				
				return que.peek();			
			}

			if (str[0].equals("back")) {
				return back;
			}
			
			if (str[0].equals("pop")) {
				if (que.isEmpty()) {
					return -1;
				}
				
				int tmp = que.poll();
				
				if (que.isEmpty()) {
					back = -1;
				}
				
				return tmp;
			}
			
			if (str[0].equals("size")) {
				return que.size();
			}
			
			if (str[0].equals("empty")) {
				if (que.isEmpty()) {
					return 1;
				}
				
				return 0;
			}
			
		}
		
		return Integer.MAX_VALUE; // 해당 수가 출력될 일은 없음
	}
}//class















################################################################################################################
예제7)알고리즘 기초 1 / 자료구조1 / 조세퍼스 문제

*최대한 효율적이게 해라. 아래 답은 여러가지 방법을 제시한다.
*큐로 풀어라 디큐(덱)금지

https://www.acmicpc.net/problem/1158
################################################################################################################



답:



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Queue<Integer> que = new LinkedList<>();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		int[] N = new int[2];
		N[0] = Integer.parseInt(st.nextToken());
		N[1] = Integer.parseInt(st.nextToken());
				
		inputQueue(N[0]);
		
		sb.append("<");
		makeJosephus(N);
		sb.append(">");
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void inputQueue(int N) {
		for (int i = 1; i <= N; i++) {
			que.offer(i);
		}
	}
	
	public static void makeJosephus(int[] N) {
		while (!que.isEmpty()) { // 실험결과 지금처럼보다는 테두리를 아래 for로 하고 내부 내용물을 넣었을때가 더 빠르네 
			for (int j = 1; j < N[1]; j++) {
				que.offer(que.poll());
			}
			
			sb.append(que.poll()).append(", ");			
		}
//		for (int i = 0; i < N[0]; i++) {
//			for (int j = 0; j < N[1]; j++) {
//				if (j == N[1] - 1) {
//					if (i == N[0] - 1) {
//						sb.append(que.poll());
//						break;
//					}
//					sb.append(que.poll()).append(", ");
//					break;
//				}
//				
//				que.offer(que.poll());
//			}
			
//			int count = 0;
//			while (true) {
//				count++;
//				if (count % N[1] == 0) {
//					if (i == N[0] - 1) {
//						sb.append(que.poll());
//						break;
//					}
//					sb.append(que.poll()).append(", ");
//					break;
//				}
//				que.offer(que.poll());				
//			}
//		}
		
		sb.setLength(sb.length() - 2);
	}
}//class


















################################################################################################################
예제8)알고리즘 기초 1 / 자료구조1 / 덱

https://www.acmicpc.net/problem/10866
################################################################################################################

답:


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Integer> deque = new ArrayDeque<>();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		int N = Integer.parseInt(br.readLine());
		
		getOrder(N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void getOrder(int N) throws IOException {
		for (int i = 0; i < N; i++) {
			int result = runOrder();
			
			if (result != -2) {
				bw.write(String.valueOf(result));
				bw.newLine();
			}
		}
	}
	
	private static int runOrder() throws IOException {
		String[] str = br.readLine().split(" ");
		
		if (str.length == 2) { // que에 입력하는 명령
			if (str[0].equals("push_front")) {
				deque.offerFirst(Integer.parseInt(str[1]));
				return -2;
			}
			if (str[0].equals("push_back")) {
				deque.offerLast(Integer.parseInt(str[1]));
				return -2;
			}
		}
		
		{ // str.length == 1 인 경우
			{ // 삭제 및 출력하는 명령
				if (str[0].equals("pop_front")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.pollFirst();
				}
				if (str[0].equals("pop_back")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.pollLast();
				}				
			}
			{ // 출력민하는 명령
				if (str[0].equals("front")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.peekFirst();
				}
				if (str[0].equals("back")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.peekLast();
				}
			}
			{ // 그밖의 기타 명령
				if (str[0].equals("size")) {
					return deque.size();
				}
				if (str[0].equals("empty")) {
					if (deque.isEmpty()) {
						return 1;
					}
					return 0;
				}
			}
		}
		
		return Integer.MAX_VALUE;
	}
}//class
















































































21.01.03.19회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================





































































	
################################################################################################################
예제9)알고리즘 기초 1 / 자료구조 1 (연습) / 단어 뒤집기 2

*deque를 응용해서 풀어라
	-응용한경우 : 296ms
	-응용 안한경우 : 1708ms

https://www.acmicpc.net/problem/17413
################################################################################################################


답(deque를 효율적으로 이용하여 que와 stack을 동시에 사용하기):
	-단어를 나누지 않음. stack, que 두개를 선언한 다른사람의 방식을 응용한것
	-논리적으로는 단어를 나누는게 더 가독성이 좋지 않나 싶지만 극명한 시간차이.. deque를
		잘 이용하자.. 

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Character> deque = new ArrayDeque<>();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		String str = inputData();
		reverseThrowDeque(str);
		bw.write(sb.toString());
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static String inputData() throws IOException {
		String str = br.readLine();
		return str;
	}

	public static void reverseThrowDeque(String str) {
		str += " ";
		boolean flag = true;
		
		for (int i = 0; i < str.length(); i++) {
			if (str.charAt(i) == '<') {
				if (!deque.isEmpty()) {
					while (!deque.isEmpty()) {
						sb.append(deque.pollLast());
					}
				}
				
				sb.append("<");
				flag = false;
			} else if (str.charAt(i) == '>') {
				while (!deque.isEmpty()) {
					sb.append(deque.pollFirst());
				}
				
				sb.append(">");
				flag = true;
			} else if (str.charAt(i) == ' ') {
				if (flag) {
					while (!deque.isEmpty()) {
						sb.append(deque.pollLast());
					}
				} else {
					while (!deque.isEmpty()) {
						sb.append(deque.pollFirst());
					}
				}
				
				sb.append(" ");	
			} else {
				deque.offerLast(str.charAt(i));
			}
		}
	}
}//class





답(단어와 태그를 먼저 구분한뒤 스택만을 이용하여 출력하는 방식):
	-처음 푼 방법, bunch가 있음. 단어와 태그를 구분한뒤 집어넣어야하니까.

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Character> deque = new ArrayDeque<>();
	private static StringBuilder sb = new StringBuilder();
	private static String[] bunch = new String[100000];
	
	public static void main(String[] args) throws IOException {
		
		String str = inputData();
		int count = cutStr(str);
		reverseThrowDeque(count);
		bw.write(sb.toString());
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static String inputData() throws IOException {
		String str = br.readLine();
		return str;
	}
	
	public static int cutStr(String str) {
		int count = 0;
		String tmp = "";

		for (int i = 0; i < str.length(); i++) {
			
			char ch = str.charAt(i);
			if (ch == '<') {
				if (tmp.length() > 0) {
					bunch[count] = tmp;
					count++;
					tmp = "";
				}
				
				while (str.charAt(i) != '>') {
					tmp += str.charAt(i);
					i++;
				}
				tmp += str.charAt(i);
				bunch[count] = tmp;
				count++;
				tmp = "";
				continue;
			}
			
			if (ch == ' ') {
				bunch[count] = tmp;
				count++;
				tmp = "";
				continue;
			}
			
			if (i == str.length() - 1) {
				tmp += str.charAt(i);
				bunch[count] = tmp;
				count++;
				tmp = "";
				continue;
			}
			tmp += str.charAt(i);
		}
		
		return count;
	}
	
	public static void reverseThrowDeque(int count) {
		for (int i = 0; i < count; i++) {
			String tmp = reverseWord(bunch[i]);
			
			if (tmp.charAt(0) == '<') {
				if (sb.length() != 0 && sb.charAt(sb.length() - 1) != '>') {
					sb.setLength(sb.length() - 1);					
				}
				sb.append(tmp);
				continue;
			}
			
			sb.append(tmp).append(' ');
		}
	}
	
	private static String reverseWord(String tmp) {
		if (tmp.charAt(0) == '<') {
			return tmp;
		}
		
		int len = tmp.length();
		for (int i = 0; i < len; i++) {
			deque.offerLast(tmp.charAt(i));
		}
		
		tmp = "";
		for (int i = 0; i < len; i++) {
			tmp += deque.pollLast();
		}
		
		return tmp;
	}
	
}//class




















################################################################################################################
예제10)알고리즘 기초 1 / 자료구조 1 (연습) / 쇠막대기

https://www.acmicpc.net/problem/10799
################################################################################################################


답:



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Character> deque = new ArrayDeque<>();
	private static Stack<Character> stack = new Stack<>();
	private static StringBuilder sb = new StringBuilder();

	private static int separationCount = 0;
	private static int barCount = 0;
	
	public static void main(String[] args) throws IOException {
		String str = inputData();
		inputDeque(str);
		calc();
		lastCalcOfSeparationCount();

		bw.write(String.valueOf(separationCount));
		bw.flush();
		bw.close();
		br.close();
	}

	public static String inputData() throws IOException {
		return br.readLine();
	}
	
//	public static void getTotalCountOfBar() { barCount때매 필요없어진 함수
//		int count = 0;
//		
//		while (!deque.isEmpty()) {
//			int top = deque.pollFirst();
//			
//			if (top == '(' && top == deque.peekFirst()) {
//				count++;
//			}
//		}
//		
//		separationCount = count;
//	}
	
	public static void inputDeque(String str) {
		for (int i = 0; i < str.length(); i++) {
			deque.offerLast(str.charAt(i));
		}
	}
	
	public static void calc() {
		int separationCount = 0;
		
		while (!deque.isEmpty()) {
			char top = deque.pollFirst();
			
			if (top == '('
					&& deque.peekFirst() == ')') { // 레이저인 경우
				int laserCount = 0;
				
				deque.pollFirst();
				laserCount++;
				while ((top = deque.pollFirst()) == '(' 
						&& deque.peekFirst() == ')') {
					deque.pollFirst();
					laserCount++;
				}
				
				deque.offerFirst(top);
				
				checkSeparation(laserCount);
				continue;
			}
			
			{ // top == deque.peekFirst() 레이저가 아닌 경우				
				if (top == '(') { // 쇠막대 하나가 시작된 경우
					stack.push(top);
					barCount++;
					continue;
				}

				if (top == ')'){ // 쇠막대 하나가 끝난 경우
					stack.pop();
					continue;
				}
			}
			
		}
	}
	
	private static void checkSeparation(int laserCount) {
		int exposedCount = stack.size();
		separationCount += exposedCount * laserCount;
	}
	
	private static void lastCalcOfSeparationCount() {
		separationCount += barCount;
	}
}//class














































































21.01.10.20회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================











































































################################################################################################################
예제11)알고리즘 기초 1 / 자료구조 1 (연습) / 오큰수

반례 : 인덱스 전에 것으로 순차적으로 스택의 값의 인덱스가 맞아떨어질거라 생각하면 아래 반례가 나옴
	-그렇기때문에 각 스택의 값에 대한 인덱스를 따로 기록해야함 이걸 클래스를 만들어서(새로운 자료구조) 한다.
6
41 3 2 1 5 4 45

https://www.acmicpc.net/problem/17298
################################################################################################################


답:


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private class Node {
		int index = 0;
		int num = 0;
		
		Node(int index, int num) {
			this.index = index;
			this.num = num;
		}
	}
	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int N;
	private int[] answer;
	private Stack<Node> stack = new Stack<>();
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		input();
		for (int i = 0; i < N; i++) {
			sb.append(answer[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
	
	private void input() throws IOException {
		this.N = Integer.parseInt(br.readLine());
		String[] read = br.readLine().split(" ");
		
		answer = new int[N];
		Arrays.fill(answer, -1);
		
		for (int i = 0; i < N; i++) {
			operateStack(new Node(i, Integer.parseInt(read[i])));
		}
	}
	
	private void operateStack(Node node) {
		while (!stack.isEmpty() && stack.peek().num < node.num) {
			answer[stack.pop().index] = node.num;
		}
		stack.add(node);
	}
}






















################################################################################################################
예제12)알고리즘 기초 1 / 자료구조 1 (연습) / 오등큰수

-3가지 방식이 있는데 가장 빠른 방식으로하라
-아래 답중 가장 아래방식이며 교훈을 읽어라

https://www.acmicpc.net/problem/17299
################################################################################################################



답(다른사람의 빠른 답 참고/입력된 수의 갯수, 입력된 수를 각각의 배열에 넣고 stack에는 
			입력된 값이 들어가는 것이 아니라 인덱스값이 들어감):
	-1128ms

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static int[] origin;
	private static int[] count = new int[1000001];
	private static int[] answer;
	private static int N;
	private static Stack<Integer> stack = new Stack<>();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		run();
	}
	
	public static void run() throws IOException {
		input();
		compare();
		writeData();
	}
	
	private static void input() throws IOException {
		N = Integer.parseInt(br.readLine());
		origin = new int[N];
		answer = new int[N];
		Arrays.fill(answer, -1);		
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		for (int i = 0; i < N; i++) {
			origin[i] = Integer.parseInt(st.nextToken());
		}
		
		for (int i = 0; i < N; i++) {
			count[origin[i]]++;
		}
	}
	
	private static void compare() {
		stack.push(0);
		
		for (int i = 1; i < N; i++) {
			while (!stack.isEmpty() && count[origin[stack.peek()]] < count[origin[i]]) {
				answer[stack.pop()] = origin[i];
			}
			stack.push(i);
		}
	}
	
	private static void writeData() throws IOException {
		for (int i = 0; i < N; i++) {
			sb.append(answer[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}







답(내가푼 답, 이전 문제에서 응용하여 hash로 값을 찾아냄, stack에 객체를(index, 값, f값 가진 객체) 넣음):
	-1528ms

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private class Node {
		int index = 0;
		int num = 0;
		int f = 0;
		
		Node(int index, int num, int f) {
			this.index = index;
			this.num = num;
			this.f = f;
		}
	}
	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int N;
	private int[] answer;
	private Stack<Node> stack = new Stack<>();
	private StringBuilder sb = new StringBuilder();
	private HashMap<Integer, Integer> hm = new HashMap<>();
	private int[] origin;
	
	public void run() throws IOException {
		input();
		for (int i = 0; i < N; i++) {
			sb.append(answer[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
	
	private void input() throws IOException {
		this.N = Integer.parseInt(br.readLine());
		String[] read = br.readLine().split(" ");
		
		answer = new int[N];
		Arrays.fill(answer, -1);
		
		origin = new int[N];
		for (int i = 0; i < N; i++) {
			origin[i] = Integer.parseInt(read[i]);
		}
		
		for (int i = 0; i < N; i++) {			
			f(i);
		}
		
		for (int i = 0; i < N; i++) {
			operateStack(new Node(i, origin[i], hm.get(origin[i])));
		}
	}
	
	private void f(int i) {
		hm.put(origin[i], hm.getOrDefault(origin[i], 0) + 1);
	}
	
	private void operateStack(Node node) {
		while (!stack.isEmpty() && stack.peek().f < node.f) {
			answer[stack.pop().index] = node.num;
		}
		stack.add(node);
	}
}



답(내가푼 답과 다른이의 답을 합침, 갯수를 배열을 이용하여 값 찾아냄, stack에 객체를(index, 값, f값 가진 객체) 넣음):
	-1092ms
		=> 교훈 : 값들을 각각 배열에 받아서 배열을 응용하는것보다 연결되는 값들은
			클래스로 모아 만든 객체를 이용해서 관리하는 것이 더 빠르다.
package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private class Node {
		int index = 0;
		int num = 0;
		int f = 0;
		
		Node(int index, int num, int f) {
			this.index = index;
			this.num = num;
			this.f = f;
		}
	}
	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int N;
	private int[] origin;
	private int[] count = new int[1000001];
	private int[] answer;
	private Stack<Node> stack = new Stack<>();
	private StringBuilder sb = new StringBuilder();

	public void run() throws IOException {
		input();
		for (int i = 0; i < N; i++) {
			sb.append(answer[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
	
	private void input() throws IOException {
		this.N = Integer.parseInt(br.readLine());
		String[] read = br.readLine().split(" ");
		
		answer = new int[N];
		Arrays.fill(answer, -1);
		
		origin = new int[N];
		for (int i = 0; i < N; i++) {
			origin[i] = Integer.parseInt(read[i]);
		}
		
		for (int i = 0; i < N; i++) {			
			count[origin[i]]++;
		}
		
		for (int i = 0; i < N; i++) {
			operateStack(new Node(i, origin[i], count[origin[i]]));
		}
	}
	
	private void operateStack(Node node) {
		while (!stack.isEmpty() && stack.peek().f < node.f) {
			answer[stack.pop().index] = node.num;
		}
		stack.add(node);
	}
}



































































































































21.01.11.21회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================





















































































































################################################################################################################
예제13)알고리즘 기초 1 / 자료구조 1 (참고) / 후위 표기식2

https://www.acmicpc.net/problem/1935
################################################################################################################


답(내가 처음 푼 답, hashMap을 이용해서 문자와 해당하는 값을 대응시킴):
	-배열보다 hashMap이 조금 더 빠름
	-128ms


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private HashMap<Character, Integer> hm = new HashMap<>();
//	private Stack<Double> intStack = new Stack<>();
	private Stack<Double> doubleStack = new Stack<>();
	private int N;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {	
		this.N = Integer.parseInt(br.readLine());
		this.str = br.readLine();
		
		for (int i = 0, count = 0; i < str.length(); i++) {
			if (count == N) {
				break;
			}
			
			if (str.charAt(i) < 65 || str.charAt(i) > 90) {
				continue;
			}
			
			if (hm.containsKey(str.charAt(i))) {
				continue;
			}
			
			hm.put(str.charAt(i), Integer.parseInt(br.readLine()));
			count++;
		}
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			
			if (ch >= 65 && ch <= 90) {	
				doubleStack.push((double) hm.get(ch));
				continue;
			}
			
			operateStack(ch);
		}
	}
	
	private void operateStack(char ch) {
		if (ch == '+') {
			double tmp = doubleStack.pop() + doubleStack.pop();
			doubleStack.push(tmp);
			return;
		}
		if (ch == '-') {
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp = o1 - o2;
			doubleStack.push(tmp);
			return;
		}
		if (ch == '*') {
			double tmp = doubleStack.pop() * doubleStack.pop();
			doubleStack.push(tmp);
			return;
		}
		if (ch == '/') {
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp =  o1 / o2;
			doubleStack.push(tmp);
			return;
		}
		{ // ch == '%'
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp =  o1 % o2;
			doubleStack.push(tmp);
		}
	}
	
	private void printData() throws IOException {
		String result = String.format("%.2f", doubleStack.get(0));
		bw.write(result);
		bw.flush();
		bw.close();
		br.close();
	}
}



답(다른사람거 참고, 배열을 이용하여 문자와 해당하는 값을 대응시킴):
	-140ms


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
//	private HashMap<Character, Integer> hm = new HashMap<>();
//	private Stack<Double> intStack = new Stack<>();
	private Stack<Double> doubleStack = new Stack<>();
	private int N;
	private double[] arr;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {	
		this.N = Integer.parseInt(br.readLine());
		this.str = br.readLine();
		arr = new double[N];
		
		for (int i = 0, count = 0; i < str.length(); i++) {
			if (count == N) {
				break;
			}
			
			if (str.charAt(i) < 65 || str.charAt(i) > 90) {
				continue;
			}
			
			
//			if (hm.containsKey(str.charAt(i))) {
//				continue;
//			}
			
			arr[count] = Integer.parseInt(br.readLine()); 
//			hm.put(str.charAt(i), Integer.parseInt(br.readLine()));
			count++;
		}
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			
			if (ch >= 65 && ch <= 90) {	
				doubleStack.push(arr[ch - 'A']);
				continue;
			}
			
			operateStack(ch);
		}
	}
	
	private void operateStack(char ch) {
		if (ch == '+') {
			double tmp = doubleStack.pop() + doubleStack.pop();
			doubleStack.push(tmp);
			return;
		}
		if (ch == '-') {
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp = o1 - o2;
			doubleStack.push(tmp);
			return;
		}
		if (ch == '*') {
			double tmp = doubleStack.pop() * doubleStack.pop();
			doubleStack.push(tmp);
			return;
		}
		if (ch == '/') {
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp =  o1 / o2;
			doubleStack.push(tmp);
			return;
		}
		{ // ch == '%'
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp =  o1 % o2;
			doubleStack.push(tmp);
		}
	}
	
	private void printData() throws IOException {
		String result = String.format("%.2f", doubleStack.get(0));
		bw.write(result);
		bw.flush();
		bw.close();
		br.close();
	}
}

























################################################################################################################
예제14)알고리즘 기초 1 / 자료구조 1 (참고) / 후위 표기식

// A + B * C + D
//ABC*+D+
//A + B * (C + D) 
//ABCD+*+
//A+B*C-(D+E)
//ABC*+DE+-
//A+B*(C+D)+(E+F)
//ABCD+EF++*+
//연속된 괄호


https://www.acmicpc.net/problem/1918
################################################################################################################


답:


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private String str;
	private StringBuilder sb = new StringBuilder();
	private Stack<Character> stack = new Stack<>();
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {
		str = br.readLine();
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			
			if (ch >= 65 && ch <= 90) {
				sb.append(ch);
				continue;
			}
			
			if (ch == ')') {
				while (!stack.isEmpty() && stack.peek() != '(') {
					sb.append(stack.pop());
				}
				stack.pop();
				continue;
			}	
			//A + B * C * D
			//ABC*D*+
			{ // ch == (, -, +, *, /인 경우
				while (!stack.isEmpty() && getPriorityScore(ch) != 0 
						&& getPriorityScore(stack.peek()) >= getPriorityScore(ch)) {
					sb.append(stack.pop());
				}
				stack.push(ch);
			}
			
		}
		
		while (!stack.isEmpty()) {
			sb.append(stack.pop());
		}
	}
	
	private int getPriorityScore(char ch) {
		if (ch == '(') {
			return 0;
		}
		
		if (ch == '+' || ch == '-') {
			return 1;
		}
		
		{ // ch == '*' || ch == '/' 의 경우임, ch == ')'인 경우는 해당 메소드로 안들어옴 
			return 2;			
		}
	}
	
	private void printData() throws IOException {
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}






실패한 코드(해당코드는 틀린 코드임):

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class
// A + B * C + D
//ABC*+D+
//A + B * (C + D) 
//ABCD+*+
//A+B*C-(D+E)
//ABC*+DE+-
//A+B*(C+D)+(E+F)
//ABCD+EF++*+
class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private Queue<Character> wordQue = new LinkedList<>();
	private Stack<Character> operatorStack = new Stack<>();
	private String str;
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		input();
		calc();
		appendData();
		printData(); 
	}
	
	private void input() throws IOException {	
		str = br.readLine();
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			
			if (ch >= 65 && ch <= 90) {
				runWordStack(ch);
				continue;
			}
			
			if (!operatorStack.isEmpty() && (operatorStack.peek() == '*' 
					|| operatorStack.peek() == '/')) {
				if (ch == '+' || ch == '-') {
					appendData();
					i--;
					continue;
				}
			}
			
			
			
			runOperatorStack(ch);
		}
	}
	
	private void runWordStack(char ch) {
		wordQue.offer(ch);
	}
	
	private void runOperatorStack(char ch) {
		operatorStack.push(ch);
	}
	
	private void appendData() {
		while (!wordQue.isEmpty()) {
			sb.append(wordQue.poll());			
		}
		while (!operatorStack.isEmpty()) {
			if (operatorStack.peek() == ')' 
					|| operatorStack.peek() == '(') {
				operatorStack.pop();
			}
			sb.append(operatorStack.pop());			
		}
	}
	
	private void printData() throws IOException {
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}



































































21.01.13.22회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================



































































################################################################################################################
예제15)알고리즘 기초 1 / 자료구조 1 (참고) / 알파벳 개수

https://www.acmicpc.net/problem/10808
################################################################################################################


답:




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private int N;
	private int[] arr = new int[26];
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException{
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {
		str = br.readLine();
		N = str.length();
	}
	
	private void calc() {
		for (int i = 0; i < N; i++) {
			arr[str.charAt(i) - 'a']++;
		}
	}
	
	private void printData() throws IOException {
		for (int i = 0; i < 26; i++) {
			sb.append(arr[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}	






















################################################################################################################
예제16)알고리즘 기초 1 / 자료구조 1 (참고) / 알파벳 찾기

https://www.acmicpc.net/problem/10809
################################################################################################################


답:





package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private int N;
	private int[] arr = new int[26];
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException{
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {
		str = br.readLine();
		N = str.length();
		Arrays.fill(arr, -1);
	}
	
	private void calc() {
		for (int i = 0; i < N; i++) {
			if (arr[str.charAt(i) - 'a'] != -1) {
				continue;
			}
			arr[str.charAt(i) - 'a'] = i;
		}
	}
	
	private void printData() throws IOException {
		for (int i = 0; i < 26; i++) {
			sb.append(arr[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}	


















################################################################################################################
예제17)알고리즘 기초 1 / 자료구조 1 (참고) / 문자열 분석

https://www.acmicpc.net/problem/10820
################################################################################################################


답:




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	private String str;
	private Queue<Node> que = new LinkedList<>();
	
	public void run() throws IOException{
		str = "";
		while ((str = br.readLine()) != null) {
			printData(str);			
		}
		
		bw.close();
		br.close();
	}
	
	private void printData(String nodeStr) throws IOException {
		Node node = new Node();
		node.printData(nodeStr, bw);
	}
}

class Node {
	private StringBuilder sb = new StringBuilder();
	
	private static final int SMALL = 1;
	private static final int BIG = 2;
	private static final int NUM = 3;
	private static final int SPACE = 4;
	
	private int smallCount = 0;
	private int bigCount = 0;
	private int numCount = 0;
	private int spaceCount = 0;
	
	public Node() {
		super();
	}
	private Node(int small, int big, int num, int space) {
		this.smallCount = small;
		this.bigCount = big;
		this.numCount = num;
		this.spaceCount = space;
	}
	
	public void printData(String nodeStr, BufferedWriter bw) throws IOException {
		setData(nodeStr);
		appendData();
		writeData(bw);
	}
	
	private void setData(String nodeStr) {
		for (int i = 0; i < nodeStr.length(); i++) {
			int result = check(nodeStr.charAt(i));
			
			if (result == BIG) {
				this.bigCount++;
				continue;
			}
			
			if (result == SMALL) {
				this.smallCount++;
				continue;
			}
			
			if (result == NUM) {
				this.numCount++;
				continue;
			}
			
			{ // result == SPACE
				this.spaceCount++;
			}
		}
	}
	
	private int check(char ch) {
		if (ch >= 65 && ch <= 90) {
			return BIG;
		}
		
		if (ch >= 97 && ch <= 122) {
			return SMALL;
		}
		
		if (ch >= 48 && ch <= 57) {
			return NUM;
		}
		
		{ // ch == ' ' 
			return SPACE;
		}
	}
	
	private void appendData() {
		sb.append(smallCount + " " + bigCount + " "
				+ numCount + " " + spaceCount + "\n");
	}
	
	private void writeData(BufferedWriter bw) throws IOException {
		bw.write(sb.toString());
		bw.flush();
	}
}













################################################################################################################
예제18)알고리즘 기초 1 / 자료구조 1 (참고) / 단어 길이 재기

이문제는 무슨 의미가 있는지 잘 모르겠다.

https://www.acmicpc.net/problem/2743
################################################################################################################


답:



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public void run() throws IOException {
		String str = br.readLine();
		System.out.println(str.length());
	}

}









################################################################################################################
예제19)알고리즘 기초 1 / 자료구조 1 (참고) / ROT13(카이사르암호)

*답에는 자료구조측면에서 푸는법 1가지와 수학적측면에서 푸는법 2가지가 있다.
	-수학적측면 방식 2개 차이
		-26개로 되어있으니 주기가 13씩 갔을때 두번가면 다시 처음으로 돌아온다는 것을 이용하여
			간편하게 식 도출
		-직접적으로 넘어간것을 가져와서 맞추는 식으로 식 도출

https://www.acmicpc.net/problem/11655
################################################################################################################


답(내가 자료구조 측면에서 푼 코드):

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	// 수학적으로 풀지 않고 자료구조 측면에서 푼 답
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private char[] arr; 
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		str = br.readLine();
		arr = str.toCharArray();
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			if (!(ch >= 65 && ch <= 90)
					&& !(ch >= 97 && ch <= 122)) {
				continue;
			}
			
			operateQue(ch, i);
		}
	}
	
	private void operateQue(char ch, int i) {
		Queue<Integer> que = new LinkedList<>();
		setQue(que); // 대소문자 a~z 입력과정
		
		if (ch >= 65 && ch <= 90) {
			fixQue(que, ch, 'A');
			arr[i] = (char) (que.peek() + 'A');
			que.clear();
			return; 
		}
		
		fixQue(que, ch, 'a');
		arr[i] = (char) (que.peek() + 'a');
		que.clear();
	}
		
	private void setQue(Queue<Integer> que) {
		for (int i = 0; i < 26; i++) {
			que.offer(i);
		}
	}
	
	private void fixQue(Queue<Integer> que, char ch, char first) {
		while (que.peek() != ch - first) {
			que.offer(que.poll());
		}			
		
		for (int i = 0; i < 13; i++) {
			que.poll();
		}
	}
	
	private void printData() throws IOException {
		str = String.copyValueOf(arr);
		writeData(str);
	}
	
	private void writeData(String str) throws IOException {
		bw.write(str);
		bw.flush();
		bw.close();
		br.close();
	}
}








답(내가 수학적으로 푼 코드):


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private char[] copyStr;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		str = br.readLine();
		copyStr = str.toCharArray();
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			if (!(ch >= 65 && ch <= 90)   
					&& !(ch >= 97 && ch <= 122)) {
				continue;
			}
			
			if ((ch >= 65 && ch <= 90)
					&& copyStr[i] + 13 > 90) { // 대문자 범위를 넘어서는 경우
				copyStr[i] = (char) (((copyStr[i] + 13) - 90) + 64);
				continue;
			}
			
			if ((ch >= 97 && ch <= 122)
					&& copyStr[i] + 13 > 122) { // 소문자 범위를 넘어서는 경우 
				copyStr[i] = (char) (((copyStr[i] + 13) - 122) + 96);
				continue;
			}
			
			
			{ // 더해도 대문자 및 소문자 범위를 넘어서지 않는 경우				
				copyStr[i] += 13;
			}
		}
	}
	
	private void printData() throws IOException {
		str = String.copyValueOf(copyStr);
		writeData();
	}
	
	private void writeData() throws IOException {
		bw.write(str);
		bw.flush();
		bw.close();
		br.close();
	}
}







답(타인이 수학적으로 푼 답을 응용한 코드):


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private char[] copyStr;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		str = br.readLine();
		copyStr = str.toCharArray();
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			if (!(ch >= 65 && ch <= 90)   
					&& !(ch >= 97 && ch <= 122)) {
				continue;
			}
			
			if ((ch >= 'N' && ch <= 'Z') 
			 		|| (ch >= 'n' && ch <= 'z')){ // 더했을 때 대문자 또는 소문자 범위를 넘어서는 경우
				copyStr[i] -= 13;
				continue;
			}
			
			{ // 더해도 대문자 또는 소문자 범위를 넘어서지 않는 경우				
			  // (ch >= 'A' && ch <= 'M') || (ch >= 'a' && ch <= 'm') 
				copyStr[i] += 13;
			}
		}
	}
	
	private void printData() throws IOException {
		str = String.copyValueOf(copyStr);
		writeData();
	}
	
	private void writeData() throws IOException {
		bw.write(str);
		bw.flush();
		bw.close();
		br.close();
	}
}





















################################################################################################################
예제20)알고리즘 기초 1 / 자료구조 1 (참고) / 네 수


https://www.acmicpc.net/problem/10824
################################################################################################################


답:





package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str1;
	private String str2;
	
	public void run() throws IOException {
		input();
		long result = calc();
		printData(result);
	}

	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		str1 = st.nextToken();
		str1 += st.nextToken();
		str2 = st.nextToken();
		str2 += st.nextToken();
	}
	
	private long calc() {
		long num1 = Long.parseLong(str1);
		long num2 = Long.parseLong(str2);
		
		return num1 + num2;
	}
	
	private void printData(long result) throws IOException {
		bw.write(String.valueOf(result));
		bw.flush();
		bw.close();
		br.close();
	}
}















################################################################################################################
예제21)알고리즘 기초 1 / 자료구조 1 (참고) / 접미사 배열


https://www.acmicpc.net/problem/11656
################################################################################################################


답:


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private String[] strArr;
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		str = br.readLine();
		strArr = new String[str.length()];
	}
	
	private void calc() {
		makeSub(); // 접미사를 만드는 함수
		Arrays.sort(strArr);
	}
	
	private void makeSub() {
		for (int i = 0; i < str.length(); i++) {
			strArr[i] = str.substring(i);
		}		
	}

	private void printData() throws IOException {
		for (int i = 0; i < strArr.length; i++) {
			sb.append(strArr[i] + "\n");
		}
		writeData();
	}
	
	private void writeData() throws IOException {
		bw.write(sb.toString());			
		bw.flush();
		bw.close();
		br.close();
	}
}



































































21.01.14.23회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================






























































################################################################################################################
예제22)알고리즘 기초 1 / 수학 1 / 나머지

https://www.acmicpc.net/problem/10430
################################################################################################################


답:




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int[] arr = new int[3];
	
	public void run() throws IOException {
		input();
		calc();
//		printData();
	}
	
	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		for (int i = 0; i < 3; i++) {
			arr[i] = Integer.parseInt(st.nextToken());
		}
	}
	
	private void calc() {
		System.out.println((arr[0] + arr[1]) % arr[2]);
		System.out.println(((arr[0] % arr[2]) + (arr[1] % arr[2])) % arr[2]);
		System.out.println((arr[0] * arr[1]) % arr[2]);
		System.out.println(((arr[0] % arr[2]) * (arr[1] % arr[2])) % arr[2]);
	}
}




















################################################################################################################
예제23)알고리즘 기초 1 / 수학 1 / 최대공약수와 최소공배수

*답이 4개다.

https://www.acmicpc.net/problem/2609
################################################################################################################


답(바로 아랫답을 풀고나서 다른사람 풀이 구글링한후 더 쉬운 유클리드호제법 재귀가 있어서 내거에 맞춤
	, 결국 같은 논리인데 생각이 짧았음):
	-128ms
		-원래코드가 조금 빠르긴하지만 재귀쓰는거 자체가 가독성때매 쓰니까 해당 코드를 쓰는게 좋을듯

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int A;
	private int B;
	private int gcdResult;
	private int lcmResult;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		A = Integer.parseInt(st.nextToken());
		B = Integer.parseInt(st.nextToken());
	}
	
	private void calc() {
		calcGcd(A, B);
		calcLcm();
	}
	
	private void calcGcd(int a, int b) {
		if (b == 0) {
			gcdResult = a;
			return;
		}
		
		int result = a % b;
		calcGcd(b, result);
	}
	
	private void calcLcm() {
		int tmp1 = A / gcdResult;
		int tmp2 = B / gcdResult;
		
		lcmResult = gcdResult * tmp1 * tmp2;
	}
	
	private void printData() throws IOException {
		bw.write("" + gcdResult);
		bw.newLine();
		bw.write("" + lcmResult);
		
		bw.flush();
		bw.close();
		br.close();
	}
}




답(내가 처음 푼 재귀 답):
	-124ms
	-다른 답들보다 가장 빠르고 이건 규칙성을 알아야한다.

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int A;
	private int B;
	private int gcdResult;
	private int lcmResult;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		A = Integer.parseInt(st.nextToken());
		B = Integer.parseInt(st.nextToken());
	}
	
	private void calc() {
		calcGcd(A, B);
		calcLcm();
	}
	
	private void calcGcd(int a, int b) {
		if (a / b == 0) {
			calcGcd(b, a);
			return;
		}
		
		int result = a % b;
		if (result == 0) {
			gcdResult = b;
			return;
		}
		
		calcGcd(b, result);
	}
	
	private void calcLcm() {
		int tmp1 = A / gcdResult;
		int tmp2 = B / gcdResult;
		
		lcmResult = gcdResult * tmp1 * tmp2;
	}
	
	private void printData() throws IOException {
		bw.write("" + gcdResult);
		bw.newLine();
		bw.write("" + lcmResult);
		
		bw.flush();
		bw.close();
		br.close();
	}
}





답(cpp코드, 다른 사람이 작은 수의 약수중 큰값부터 찾아내려가면서 기존의 값에 나눠서 떨어지면 그값을 사용하는
	방식):

#include <iostream>
using namespace std;
main() {
    int a, b, i;
    cin >> a >> b;
    if (a >= b) {
        i = b;
    }
    else {
        i = a;
    }
    while (i) {
        if (a % i == 0 && b % i == 0) {
            cout << i << '\n';
            break;
        }
        else {
            i--;
        }
    }
    cout << a * b / i;
}



답(위 cpp코드를 자바로 바꾼것):
	-128ms 확실히 아래 재귀보다 빠르다. 재귀라서 그런건지 약수를 찾아오는게 느린건지 모르겠다.
package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int a;
	private int b;
	
	public void run() throws IOException {
		input();
		calc();
//		printData();
	}
	
	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		a = Integer.parseInt(st.nextToken());
		b = Integer.parseInt(st.nextToken());
	}
	
	private void calc() {
		int i = 0;
		
		if (a >= b) {
	        i = b;
	    }
	    else {
	        i = a;
	    }
		
	    while (i != 0) {
	        if (a % i == 0 && b % i == 0) {
	            System.out.println(i);
	            break;
	        }
	        else {
	            i--;
	        }
	    }
	    
	    System.out.println(i * (a / i) * (b / i));
	}
	
	private void printData() throws IOException {

	}
}

딥(위에 다른사람 답 보고 응용해서 재귀로 만든 답):
	-위 다른사람답은 1식 계속 빼서 주는거고 내가 응용한건 약수를 뽑아서 약수만 주는거
	-136ms


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int A;
	private int B;
	private int gcdResult;
	private int lcmResult;
	private int divisor;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		A = Integer.parseInt(st.nextToken());
		B = Integer.parseInt(st.nextToken());
	}
	
	private void calc() {
		calcGcd();
		calcLcm();
	}
	
	private void calcGcd() { 
		if (A > B) {
			divisor = B;
			calcGcd(A, divisor);
		} else {
			divisor = A;
			calcGcd(B, divisor);
		}
	}
	
	private void calcGcd(int a, int b) {
		int result = a % b;
		if (result == 0) {
			gcdResult = b;
			return;
		}
	
		calcGcd(a, getDivisor(b));
	}
	
	private int getDivisor(int b) {
		for (int i = --b; i >= 1; i--) {
			if (divisor % i == 0) {
				return i;
			}
		}
		
		return Integer.MAX_VALUE; // 출력되지 않을 수
	}
	
	private void calcLcm() {
		int tmp1 = A / gcdResult;
		int tmp2 = B / gcdResult;
		
		lcmResult = gcdResult * tmp1 * tmp2;
	}
	
	private void printData() throws IOException {
		bw.write("" + gcdResult);
		bw.newLine();
		bw.write("" + lcmResult);
		
		bw.flush();
		bw.close();
		br.close();
	}
}





답(두번째답에서 몫을 일일히 구해서 gcd와 곱해서 최소공배수를 구하는데 
	그런 과정없이 가독성을 위해 gcd / a * b로 최소공배수를 구한 방법임):
	-128ms 몫을 구해서 바로 곱하는 것보다 좀 느린듯 하다
		a,b의 값이 커질수록 큰수의 연산이 일어나서 그런듯하다.
		두번째답 속도 : 124ms

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int A;
	private int B;
	private int gcdResult;
	private int lcmResult;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		A = Integer.parseInt(st.nextToken());
		B = Integer.parseInt(st.nextToken());
	}
	
	private void calc() {
		calcGcd(A, B);
		calcLcm();
	}
	
	private void calcGcd(int a, int b) {
		if (a / b == 0) {
			calcGcd(b, a);
			return;
		}
		
		int result = a % b;
		if (result == 0) {
			gcdResult = b;
			return;
		}
		
		calcGcd(b, result);
	}
	
	private void calcLcm() {
		lcmResult = (A * B) / gcdResult;
	}
	
	private void printData() throws IOException {
		bw.write("" + gcdResult);
		bw.newLine();
		bw.write("" + lcmResult);
		
		bw.flush();
		bw.close();
		br.close();
	}
}
















################################################################################################################
예제24)알고리즘 기초 1 / 수학 1 / 최소공배수


https://www.acmicpc.net/problem/1934	
################################################################################################################


답:




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int A;
	private int B;
	private int gcdResult;
	private int lcmResult;
	int N;
	
	public void run() throws IOException {
		input();
		
		bw.close();
		br.close();
	}
	
	private void input() throws IOException {
		N = Integer.parseInt(br.readLine());
		for (int i = 0; i < N; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			A = Integer.parseInt(st.nextToken());
			B = Integer.parseInt(st.nextToken());
			calc();
			printData();
		}
	}
	
	private void calc() {
		calcGcd(A, B);
		calcLcm();
	}
	
	private void calcGcd(int a, int b) {
		if (b == 0) {
			gcdResult = a;
			return;
		}
		
		int result = a % b;
		calcGcd(b, result);
	}
	
	private void calcLcm() {
		lcmResult = (A * B) / gcdResult;
	}
	
	private void printData() throws IOException {
		bw.write("" + lcmResult);
		bw.newLine();
		bw.flush();
	}
}


















################################################################################################################
예제25)알고리즘 기초 1 / 수학 1 /

*약수는 모두 대칭되기때문에 낮은수에서부터 나눴을때 0으로 나누어떨어지면 해당하는 몫도 약수이며
	범위는 제곱근보다 작게하면된다.
	-나누어떨어질때 몫도 모두 배열에 집어넣고 나중에 오름차순정렬하면 된다.

*약수의 갯수가 짝수인지 홀수인지 파악하려면 제시된 수가 완전제곱수인지 아닌지 파악하면된다.
	-완전제곱수라면 기준점이 약수로 있는것이니 그 좌우에 대칭점들이 있으므로 홀수이고
		완전제곱수가 아니라면 기준점이 약수로 없는것이니 좌우 대칭점이 짝수개임으로 짝수

*그럼 소수는 약수의 갯수가 2개인 수니까 특정수의 제곱근 이하에 모든 약수의 대칭수가있으니 그중에 하나라도 나오면
	소수가 아닌것으로 판별하면 된다.

https://www.acmicpc.net/problem/
################################################################################################################


답:





package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	int N;
	int[] arr;
	int count = 0;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		N = Integer.parseInt(br.readLine());
		arr = new int[N];
		
		StringTokenizer st = new StringTokenizer(br.readLine());
		for (int i = 0; i < N; i++) {
			arr[i] = Integer.parseInt(st.nextToken());
		}
	}
	
	private void calc() {
		for (int i = 0; i < N; i++) {
			if (isPrime(i)) {
				count++;
			}
		}
	}
	
	private boolean isPrime(int i) {
		if (arr[i] == 1) {
			return false;
		}
		
		for (int j = 2; j <= Math.sqrt(arr[i]); j++) {
			if (arr[i] % j == 0) {
				return false;
			}
		}
		
		return true;
	}
	
	private void printData() throws IOException {
		bw.write(String.valueOf(count));
		bw.flush();
		bw.close();
		br.close();
	}
}














################################################################################################################
예제26)알고리즘 기초 1 / 수학 1 / 소수 구하기

https://www.acmicpc.net/problem/1929
################################################################################################################


답:



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	int[] arr = new int[2];
	int count = 0;
	StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		for (int i = 0; i < 2; i++) {
			arr[i] = Integer.parseInt(st.nextToken());
		}
	}
	
	private void calc() {
		for (int i = arr[0]; i <= arr[1]; i++) {
			if (isPrime(i)) {
				sb.append(i + "\n");
			}
		}
	}
	
	private boolean isPrime(int i) {
		if (i == 1) {
			return false;
		}
		
		for (int j = 2; j <= Math.sqrt(i); j++) {
			if (i % j == 0) {
				return false;
			}
		}
		
		return true;
	}
	
	private void printData() throws IOException {
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}






































































21.01.15.24회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================






























































################################################################################################################
예제26)알고리즘 기초 1 / 수학 1 / 소수 구하기 (답추가)

https://www.acmicpc.net/problem/1929
################################################################################################################




답(에라토네스의 체 개념을 적용시켜서 푼 답):
	-284ms
package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private boolean[] sieve; // true인 원소는 소수가 아니고, false인 원소는 소수임
	private int[] arr = new int[2];
	
	int count = 0;
	StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		for (int i = 0; i < 2; i++) {
			arr[i] = Integer.parseInt(st.nextToken());
		}
		
		sieve = new boolean[arr[1] + 1];
		sieve[0] = true; // 0, 1은 소수가 아니니 미리 체크 물론 0은 안해도 상관없긴함. 찾을 일이 없어서
		sieve[1] = true;
	}
	
	private void calc() {
		operateSieve(); // 에라토네스의 체를 범위에 맞게 적용시켜 소수인지 아닌지 판별하는 함수
	}
	
	private void operateSieve() {		
		for (int i = 2; i * i <= arr[1]; i++) { // i * i 앞에 long을 지워도 된다.
		// 이전 i <= arr[1] 이었던 식이면 arr[1]이 100만이라할때 아래 if에서
		// 100만 * 100만까지 나올수 있기에 아래 if에서 long을 해주어야했지만 (21억넘으니까)
		// 애초에 for 제한에서 i*i <= 백만 이면 i*i를 아무리 해봐야 아래 if에서 21익을 넘을리가 없다.
		// 백만보다 조금 더 높은 수가 나올수도 있겠지만 위의 제한식에서 막힌다.
			if (sieve[i] == false && i * i <= arr[1]) {
				operateSieve(i);
			}
		}
	}
	
	private void operateSieve(int i) {
		for (int j = i * i; j <= arr[1]; j += i) {
			sieve[j] = true;
		}
	}
	
	private void printData() throws IOException {
		findPrime();
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
	
	private void findPrime() {
		for (int i = arr[0]; i <= arr[1]; i++) {
			if (!sieve[i]) {
				sb.append(i + "\n");
			}
		}
	}
}










답(약수의 개수로 소수를 찾아낸 답):
	-532ms


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	int[] arr = new int[2];
	int count = 0;
	StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		for (int i = 0; i < 2; i++) {
			arr[i] = Integer.parseInt(st.nextToken());
		}
	}
	
	private void calc() {
		for (int i = arr[0]; i <= arr[1]; i++) {
			if (isPrime(i)) {
				sb.append(i + "\n");
			}
		}
	}
	
	private boolean isPrime(int i) {
		if (i == 1) {
			return false;
		}
		
		for (int j = 2; j <= Math.sqrt(i); j++) {
			if (i % j == 0) {
				return false;
			}
		}
		
		return true;
	}
	
	private void printData() throws IOException {
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}









################################################################################################################
예제27)알고리즘 기초 1 / 수학 1 / 골드바흐의 추측

*이 문제의 핵심은 기계적으로 하나하나 완전탐색처럼 다 찾아가면서 푸는게 아니라 수학적 사고를 이용하여 풀어야한다.
	그래야 속도가 빠르다. 기계적으로 해도 되긴한데 그럼 멍청이다.
*정답3이 제일 중요하다. 제일 빠르고 format 함수는 속도가 수레기가 된다는 것을 인지하자..

https://www.acmicpc.net/problem/6588
################################################################################################################


틀린 답1(젤처음에 주어지는 n만큼 계속 에라토네스의 체를 만들었던 답 메모리초과로 실패):


import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int n;
	private boolean[] sieve = new boolean[1000001];
	private List<Integer> list = new ArrayList<>();
	private int start = 0;
	private int end = 0;
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		while ((n = Integer.parseInt(br.readLine())) != 0) {
			input();
			calc();
		}
		
		printData();
	}

	private void input() throws IOException {	
		sieve = new boolean[n + 1];
		sieve[0] = true;
		sieve[1] = true;
	}
	
	private void calc() {
		operateSieve(); // 소수 판별(에라토네스의 체)
		setList(); // 소수값 list에 오름차순으로 데이터 넣기
		appendValue(); // 주어진 n에 대한 홀수인 두소수의 합을 찾아서 sb에 append하는 함수
	}
	
	private void operateSieve() {
		for (int i = 2; i * i <= n; i++) {
			operateSieve(i);
		}
	}
	
	private void operateSieve(int i) {
		for (int j = i * i; j <= n; j += i) {
			sieve[j] = true;
		}
	}
	
	private void setList() {
		for (int i = 3; i < n; i++) {
			if (!sieve[i]) {
				list.add(i);
			};
		}
	}
	
	private void appendValue() {
		setValue(); // start와 end 값을 세팅하는 함수
		sb.append(String.format("%d = %d + %d\n", n, start, end));
	}
	
	private void setValue() {
		int startIndex = 0;
		int endIndex = list.size() - 1;
		
		while (list.get(startIndex) + list.get(endIndex) != n) {
			if (list.get(startIndex) + list.get(endIndex) > n) {
				endIndex--;
				continue;
			}
			
			{ // start + end < n
				startIndex++;
			}
		}		
		
		start = list.get(startIndex);
		end = list.get(endIndex);
	}
	
	private void printData() throws IOException {
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}










틀린 답2(에라토네스의 체를 한번만 만들었어도 메모리초과로 실패한답):
	


import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int n;
	private boolean[] sieve = new boolean[1000001];
	private List<Integer> list = new ArrayList<>();
	private int start = 0;
	private int end = 0;
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		operateSieve(); // 소수 판별(에라토네스의 체)

		while ((n = Integer.parseInt(br.readLine())) != 0) {
			calc();
			list.clear();
		}
		
		printData();
	}

	private void operateSieve() {
		sieve[0] = true;
		sieve[1] = true;
		
		for (int i = 2; i * i <= 1000000; i++) {
			operateSieve(i);
		}
	}
	
	private void operateSieve(int i) {
		for (int j = i * i; j <= 1000000; j += i) {
			sieve[j] = true;
		}
	}
	
	private void calc() {
		setList(); // 소수값 list에 오름차순으로 데이터 넣기
		appendValue(); // 주어진 n에 대한 홀수인 두소수의 합을 찾아서 sb에 append하는 함수
	}
	
	private void setList() {
		for (int i = 3; i < n; i++) {
			int s = i;
			int e = n - 1;
			if (!sieve[i]) {
				
				list.add(i);
			};
		}
	}
	
	private void appendValue() {
		setValue(); // start와 end 값을 세팅하는 함수
		sb.append(String.format("%d = %d + %d\n", n, start, end));
	}
	
	private void setValue() {
		int startIndex = 0;
		int endIndex = list.size() - 1;
		
		while (list.get(startIndex) + list.get(endIndex) != n) {
			if (list.get(startIndex) + list.get(endIndex) > n) {
				startIndex = 0;
				endIndex--;
				continue;
			}
			
			{ // start + end < n
				startIndex++;
			}
		}		
		
		start = list.get(startIndex);
		end = list.get(endIndex);
	}
	
	private void printData() throws IOException {
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}


정답1(위 틀린답2에서 메모리초과 이유가 list에 매회 소수를 모두 받는 과정때문이라 생각했고 그부분을 개선한 코드):
	

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int n;
	private boolean[] sieve = new boolean[1000001];
	private List<Integer> list = new ArrayList<>();
	private int start = 0;
	private int end = 0;
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		operateSieve(); // 소수 판별(에라토네스의 체)

		while ((n = Integer.parseInt(br.readLine())) != 0) {
			calc();
		}
		
		printData();
	}

	private void operateSieve() {
		sieve[0] = true;
		sieve[1] = true;
		
		for (int i = 2; i * i <= 1000000; i++) {
			operateSieve(i);
		}
	}
	
	private void operateSieve(int i) {
		for (int j = i * i; j <= 1000000; j += i) {
			sieve[j] = true;
		}
	}
	
	private void calc() {
		setValue(); // 주어진 n에 대한 홀수인 두소수의 합을 찾아서 start, end에 넣기
		appendValue(); // 이번회차의 답을 sb에 append하는 함수
	}
	
	private void setValue() {
		int s = 3;		
		int e = n - 1;
		
		while (sieve[e]) {
			e--;
		}

		while (s + e != n) {
			if (s + e > n) {
				s = 3;
				e--;
				while (sieve[e]) {
					e--;
				}
				continue;
			}

			{ // start + end < n
				s++;
				while (sieve[s]) {
					s++;
				}
			}
		}		
		
		start = s;
		end = e;
	}
	
	private void appendValue() {
		sb.append(String.format("%d = %d + %d\n", n, start, end));
	}
	
	private void printData() throws IOException {
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}



정답2(백준님 정답을 내것으로 적용한 것. 지렸다그냥.. ):
	-n = a + b(a,b == 소수, a < b) 일때 n -a = b 형태가 된다.
		그러면 소수중 가장 적은 a값을 n에 뺐을 때 (a 값은 오름차순으로 더높은 소수의 값으로 변경한다)
		나오는 수가 b인데 이때 b는 소수 또는 일반수가 나올수있다.
		합성수가 아닌 소수라면 두 홀수인 소수의 합으로 해당 짝수가 이루어졌고 거기다가 a가 가장
		적기때문에 당연히 b가 가장 크고 그러면 b-a가 가장 큰 값이 된다.

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int n;
	private boolean[] sieve = new boolean[1000001];
	private List<Integer> list = new ArrayList<>();
	private int start = 0;
	private int end = 0;
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		operateSieve(); // 소수 판별(에라토네스의 체) 및 소수값 list에 오름차순으로 데이터 넣기
		
		while ((n = Integer.parseInt(br.readLine())) != 0) {
			calc();
		}
		
		printData();
	}

	private void operateSieve() {
		sieve[0] = true;
		sieve[1] = true;
		
		for (int i = 2; i * i <= 1000000; i++) {
			if (i == 2) {
				operateSieve(i);
				continue;
			}
			
			if (!sieve[i]) {
				list.add(i);
				operateSieve(i);	
			}
		}
	}
	
	private void operateSieve(int i) {
		for (int j = i * i; j <= 1000000; j += i) {
			sieve[j] = true;
		}
	}
	
	private void calc() {
		setValue(); // start와 end 값을 세팅하는 함수
		appendValue(); // 주어진 n에 대한 홀수인 두소수의 합을 sb에 append하는 함수
	}
	
	private void setValue() {	
		for (int i = 0; i < list.size(); i++) {
			if (!sieve[n - list.get(i)]) {				
				start = list.get(i);
				end = n - list.get(i);
				break;
			}
		}
	}
	
	private void appendValue() {
		sb.append(String.format("%d = %d + %d\n", n, start, end));
	}
	
	
	private void printData() throws IOException {
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}





정답3(은거기인의 정답을 내방식으로 적용한것. 백준님보다 빠르다.):
	-해석결과 : 아까 내가 위에서(정답1) list를 안만들고 바로 만든 방식을 백준님답에 적용하면 이리나오네
	-그리고 위의 답들은 바보같이 증명하는 것을 빼먹었다.

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int n;
	private boolean[] sieve = new boolean[1000001];
	private int start = 0;
	private int end = 0;
	private StringBuilder sb = new StringBuilder();
	private boolean flag;
	private String str;
	
	public void run() throws IOException {
		operateSieve(); // 소수 판별(에라토네스의 체)
		
		while ((n = Integer.parseInt(br.readLine())) != 0) {
			calc();
		}
		
		printData();
	}

	private void operateSieve() {
		sieve[0] = true;
		sieve[1] = true;
		
		for (int i = 2; i * i <= 1000000; i++) {
			if (!sieve[i]) {
				operateSieve(i);	
			}
		}
	}
	
	private void operateSieve(int i) {
		for (int j = i * i; j <= 1000000; j += i) {
			sieve[j] = true;
		}
	}
	
	private void calc() {
		setValue(); // start와 end 값을 세팅하는 함수
		appendValue(); // 주어진 n에 대한 홀수인 두소수의 합을 sb에 append하는 함수
	}
	
	private void setValue() {	
		flag = false;
		for (int i = 3; i < n; i++) { // j <= n / 2 안한게 더 빠름
			if (!sieve[i] && !sieve[n - i]) {
				flag = true;
				start = i;
				end = n - i;
//				str = n + " = " + i + " + " + (n - i);
				// 여기서 바로 str 먹이는거보다 start, end만 넣고 나와서 appendValue()에서
				// 먹이니까 더 빨라짐.. 무슨 차이인가 싶다. 전역변수만 두개 더 늘어나서 더 느릴줄 알았는데.
				// 다시 돌려보니 돌릴때마다 시간이 다르다 ㅋㅋ 걍 똑같은 수준이라 생각하면될듯 
				// 전역변수에 넣는건 내가보기에 이게 더 가독성이  좋아보여서 이렇게 넣음 
				break;
			}
		}
	}
	
	private void appendValue() {
		if (!flag) { // 골드바흐의 추측이 틀린경우
			sb.append("Goldbach's conjecture is wrong.\n");
			return;
		}
		
		{ // flag == true, 즉 골드바흐의 추측이 틀리지 않은 경우
			str = n + " = " + start + " + " + end + "\n";
			sb.append(str);
//			sb.append(String.format("%d = %d + %d\n", n, start, end));
			//이놈 format 돌리니 시간이 1196ms로 됨;; 안돌렸을때는 420ms.. format 함수 쓰레기인듯..
			// 뭐에서 속도가 느려지는가 찾느라고 하루종일 걸렸네 젠장
		}
	}
	
	
	private void printData() throws IOException {
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}




















################################################################################################################
예제28)알고리즘 기초 1 / 수학 1 / 팩토리얼

https://www.acmicpc.net/problem/10872
################################################################################################################



답:





import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int N;

	public void run() throws IOException {
		input();
		int result = calc(N);
		System.out.println(result);
	}

	private void input() throws IOException {
		N = Integer.parseInt(br.readLine());
	}

	private int calc(int N) {
		if (N == 0) {
			return 1;
		}
		if (N == 1) {
			return 1;
		}
		return N * calc(N - 1);
		//5 * calc(4)   120
		//		4 * calc(3) 24
		//			 3 * calc(2) 6
		//					2 * calc(1) 2
		//						1 
	}

	private void printData() throws IOException {
	
	}
}








################################################################################################################
예제29)알고리즘 기초 1 / 수학 1 / 팩토리얼 0의 개수

https://www.acmicpc.net/problem/1676
################################################################################################################



답(팩토리얼과 5의 규칙성으로 푼 코드):
	-규칙성: 팩토리얼 인수를 5로 나눈 몫을 0이될때까지 몫들을 나눴을때 몫의 합은 5의 지수와 같다.
		그리고 2의 지수가 5의 지수보다 많고 그래서 5의 지수 갯수만 신경쓰면 된다.




import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int N;
	private int count = 0;

	public void run() throws IOException {
		input();
		calc();
		System.out.println(count);
	}

	private void input() throws IOException {
		N = Integer.parseInt(br.readLine());
	}

	private void calc() {
		while (N != 0) { 
			count += N / 5;
			N /= 5;
		}
	}
	
	private void printData() throws IOException {
	
	}
}










































































21.01.25.25회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================



















































































################################################################################################################
예제30)두 수의 곱에 대한 0의 개수 ( 내가 내게 된 문제 )

*이다음 31번문제 잘못이해해서 푼 문제임
* 잘못이해한 문제 내용 : 입력되는 두 수의 곱에 대한 0의 개수를 출력하시오
	-위 내용에 대해 푼 답안임

################################################################################################################



답(팩토리얼과 5의 규칙성으로 푼 코드):
	-규칙성: 팩토리얼 인수를 5로 나눈 몫을 0이될때까지 몫들을 나눴을때 몫의 합은 5의 지수와 같다.
		그리고 2의 지수가 5의 지수보다 많고 그래서 5의 지수 갯수만 신경쓰면 된다.





import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	int[] arr = new int[2];
	Stack<Integer> twoStack = new Stack<>();
	Stack<Integer> fiveStack = new Stack<>();
	
	public void run() throws IOException {
		input();
		int result = calc();
		printData(result);
	}
	
	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		arr[0] = Integer.parseInt(st.nextToken());
		arr[1] = Integer.parseInt(st.nextToken());
	}
	
	private int calc() {
		return getCount();
	}
	
	private int getCount() {
		primeFactorization(arr[0]);
		primeFactorization(arr[1]);
		
		if (twoStack.size() >= fiveStack.size()) {
			return fiveStack.size(); // 지수가 적은 녀석의 수만큼 끝자리에 0의 개수가 있다.
		} 
		
		return twoStack.size();
	}
	
	private void primeFactorization(int N) {
		if (N == 1) {
			return;
		}
		
		if (N % 5 == 0) {
			fiveStack.push(0);
			N /= 5;
		} else if (N % 2 == 0) {
			twoStack.push(0);
			N /= 2;
		} else {
			return;
		}
		
		primeFactorization(N);
	}
	
	private boolean isTwoCountBigger() {
		
		
		return false;
	}
	
	private void printData(int result) throws IOException {
		bw.write(String.valueOf(result));
		bw.flush();
		bw.close();
		br.close();
	}
}




























################################################################################################################
예제31)알고리즘 기초 1 / 수학 1 / 조합 0의 개수 

*이항계수에 관한 문제임
*하나의 팩토리얼값에 한해서는 반드시 5의 지수가 더 작지만 팩토리얼값끼리의 나누기 곱하기 연산을 통한 뒤의 값은
	반드시 5의 지수가 작진 않다. 즉 2의 지수가 더 작은 경우도 있다. 그래서 5의 지수와 2의 지수
	를 둘다 구해서 작은 지수로 해야한다. 팩토리얼에선 항상 5의 지수가 작으니 5의 지수를 답으로 내면되지만
	복합연산에선 그렇지 않다는 뜻이다. 일일히 두개다 구해서 누가더 낮은지를 파악해야한다.
		ex) 5 1	 답 : 0 , 5의 지수로만 계산했을시 예상되는 오답 : 1
			-2^0 * 5^1( 120 / 24)

https://www.acmicpc.net/problem/2004
################################################################################################################


답:



import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int n;
	private int k;
	Stack<Integer> twoStack = new Stack<>();
	Stack<Integer> fiveStack = new Stack<>();
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		n = Integer.parseInt(st.nextToken());
		k = Integer.parseInt(st.nextToken());
	}
	
	private void calc() {
		int fiveCount = getFiveCount(n) - getFiveCount(n - k) - getFiveCount(k); // n!하였을때 5의 갯수, 즉 0의 갯수를 반환하는 함수
		int twoCount = getTwoCount(n) - getTwoCount(n-k) - getTwoCount(k);
		
		int count = Math.min(fiveCount, twoCount);
		System.out.println(count);
	}
	
	private int getFiveCount(int n) {
		int sum = 0;
		while (n >= 5) {
			sum += n / 5;
			n /= 5;
		}
		return sum;
	}
	
	private int getTwoCount(int n) {
		int sum = 0;
		
		while (n >= 2) {
			sum += n / 2;
			n /= 2;
		}
		
		return sum;
	}
	
	
	private void printData() throws IOException {
//		bw.write(String.valueOf(result));
		bw.flush();
		bw.close();
		br.close();
	}
}
21.12.31.17회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================





################################################################################################################
예제1)알고리즘 기초 1 / 자료구조1 / 스택

https://www.acmicpc.net/problem/10828
################################################################################################################


답 : 




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		Stack stack = new Stack();
		
		
		inputData(stack, N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void inputData(Stack stack, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			String[] str = br.readLine().split(" ");
			if (str.length == 2) {
				stack.push(Integer.parseInt(str[1]));
			} else {
				String tmp = str[0];
				if (tmp.equals("pop")) {
					if (stack.empty()) {
						bw.write("" + (-1));
						bw.newLine();
						continue;
					}
					bw.write("" + stack.pop());
					bw.newLine();
					continue;
				}
				if (tmp.equals("size")) {
					bw.write("" + stack.size());
					bw.newLine();
					continue;
				}
				if (tmp.equals("empty")) {
					if (stack.empty()) {
						bw.write("1");
						bw.newLine();
						continue;
					} 
					bw.write("0");
					bw.newLine();
					continue;
				}
				if (tmp.equals("top")) {
					if (stack.empty()) {
						bw.write("" + (-1));
						bw.newLine();
						continue;
					}				
					bw.write("" + stack.peek());
					bw.newLine();
				}
			}
		}
	}

}//class








################################################################################################################
예제2)알고리즘 기초 1 / 자료구조1 / 단어 뒤집기

https://www.acmicpc.net/problem/9093
################################################################################################################


답 : 




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		Stack stack = new Stack();
		
		inputData(stack, N);
		
		bw.close();
		br.close();
	}
	
	public static void inputData(Stack stack, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			String[] str = br.readLine().split(" ");
			inputData(stack, str, str.length);
		}
	}
	
	private static void inputData(Stack stack, String[] str, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			reverseThroughStack(stack, str[i], str[i].length());
		}
		
		bw.newLine();
		bw.flush();
	}
	
	private static void reverseThroughStack(Stack stack, String str, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			stack.push(str.charAt(i));
		}
		
		writeData(stack, N);
	}
	
	private static void writeData(Stack stack, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			bw.write(String.valueOf(stack.pop()));			
		}
		
		bw.write(" ");
	}

}//class








################################################################################################################
예제3)알고리즘 기초 1 / 자료구조1 / 괄호

https://www.acmicpc.net/problem/9012
################################################################################################################


답 : 



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());

		String[] arr = new String[N];
		
		inputData(arr, N);
		checkVPS(arr, N);
		
		bw.close();
		br.close();
	}
	
	public static void inputData(String[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			arr[i] = br.readLine();
		}
	}
	
	public static void checkVPS(String[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			Stack stack = new Stack();
			pushStack(arr[i], arr[i].length(), stack);
			boolean flag = isVPS(stack);
			writeData(flag);
		}
	}
	
	private static void pushStack(String str, int N, Stack stack) {
		for (int i = 0; i < N; i++) {
			stack.push(str.charAt(i));
		}
	}
	
	private static boolean isVPS(Stack stack) {
		if ((char) stack.peek() == '(' || stack.size() % 2 != 0) {
			return false;
		}
		
		int count = 0;
		while (!stack.empty()) {	
			while (!stack.empty() && (char) stack.peek() == ')') {
				stack.pop();
				count++;
			}
			
			while (!stack.empty() && (char) stack.peek() == '(') {
				stack.pop();
				count--;
				
				if (count == -1) {
					return false;
				}
			}
		}
		
		if (count != 0) {
			return false;
		}
		
		return true;
	}
	
	private static void writeData(boolean flag) throws IOException {
		if (flag) {
			bw.write("YES\n");
			return;
		}
		
		if (!flag) {
			bw.write("NO\n");
		}
	}
}//class





다른사람답(while안쓰고 for문사용, 새로운 char배열만들어서 앞에서부터 확인하여 빼가는데 count가 -1인경우는
	stac.isEmpty()를 활용해서 확인하고 삭제하는 방식. stack에 값이 다들어가지 않아도 된다는 면에서는
	효율적이지만 내 방식은 char배열을 안만든다는 점에서 메모리소비를 막을수 있음)




import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Stack;

public class Main {

	public static void main(String[] args) throws NumberFormatException, IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		
		int T = Integer.parseInt(br.readLine());
		for(int tc=1;tc<=T;tc++) {
			String str = br.readLine();
			char[] arr =str.toCharArray();
			
			Stack<Character> stack = new Stack<>();
			boolean flag = true;
			for(char c:arr) {
				if(c=='(') {
					stack.push(c);
				}else {
					if(stack.isEmpty()) {
						flag=false;
						break;
					}
					stack.pop();						
				}
			}
			
			if(!stack.isEmpty()) {
				flag=false;
			}
			if(!flag) {
				System.out.println("NO");
			}else {
				System.out.println("YES");
			}
		}
		
	}

}










################################################################################################################
예제4)알고리즘 기초 1 / 자료구조1 / 스택 수열

https://www.acmicpc.net/problem/1874
################################################################################################################



인터넷에 더 간결하고 직관적인 코드:
package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		int[] arr = new int[N];
				
		inputData(arr, N);
		makeBunch(arr, N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void inputData(int[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			arr[i] = Integer.parseInt(br.readLine());
		}
	}
	
	public static void makeBunch(int[] arr, int N) throws IOException {
		int j = 1;
		for (int i = 0; i < N; i++) {
			// j > arr[i] 라면 절대 stack이 비어 있을 수 없다.
				// 현재 j 전까지는 모두 스택에 push되었기 때문
			if (stack.empty() || (int) stack.peek() < arr[i]) {
				while (j <= arr[i]) {
					stack.push(j);
					sb.append("+\n");
					j++;
				}
				
				stack.pop();
				sb.append("-\n");
			} else if ((int) stack.peek() == arr[i]) {
				stack.pop();
				sb.append("-\n");
			} else if ((int) stack.peek() > arr[i]) {
				bw.write("NO");
				return;
			}
		}
		
		bw.write(sb.toString());
	}
}//class






처음 내가 낸 답 : 


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		int[] arr = new int[N];
		
	
		
		inputData(arr, N);
		makeBunch(arr, N);
		
		br.close();
	}
	
	public static void inputData(int[] arr, int N) throws IOException {
		for (int i = 0; i < N; i++) {
			arr[i] = Integer.parseInt(br.readLine());
		}
	}
	
	public static void makeBunch(int[] arr, int N) throws IOException {
		int j = 1;
		for (int i = 0; i < N; i++) {
			while (true) {
				if (arr[i] > j) {
					stack.push(j);
					sb.append("+\n");
					j++;		
					continue;
				}
				
				if (arr[i] == j) {
					stack.push(j);
					sb.append("+\n");
					stack.pop();
					sb.append("-\n");
					j++;
				
					while (!stack.empty() && i + 1 < N && arr[i + 1] == (int) stack.peek()) {
						stack.pop();
						sb.append("-\n");
						i++;
					}
							
					break;
				}

				if (!stack.empty() && arr[i] < (int) stack.peek()) {
					System.out.println("NO");
					return;
				}
			}
		}
		
//		if (!stack.empty()) {
//			System.out.println("NO");
//			return;
//		}
		
		System.out.println(sb.toString());
	}
}//class



























































































21.1.1.18회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================





























































































################################################################################################################
예제5)알고리즘 기초 1 / 자료구조1 / 에디터

https://www.acmicpc.net/problem/1406
################################################################################################################




답(else가 없게 가시적으로 편하게 정리한 코드):

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack1 = new Stack();
	private static Stack stack2 = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = 0;
		String str = "";
		N = inputData(str);
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static int inputData(String str) throws IOException {
		str = br.readLine();
		int N = Integer.parseInt(br.readLine());
		inputStack(str);
		
		for (int i = 0; i < N; i++) {
			action(str);
		}
		
		workFinish(str);
		
		return N;
	}
	
	private static void inputStack(String str) {
		for (int i = 0; i < str.length(); i++) {
			stack1.push(str.charAt(i));
		}	
	}
	
	private static void action(String str) throws IOException {
		String[] order = br.readLine().split(" ");

		if (order.length == 1) {
			if (order[0].charAt(0) == 'L') {
				if (stack1.empty()) {
					return;
				}
				
				stack2.push(stack1.pop());
				return;
			}
		
			if (order[0].charAt(0) == 'D') {
				if (stack2.empty()) {
					return;
				}
				
				stack1.push(stack2.pop());
				return;
			} 
			
			
			{ // order[0].charAt(0) == 'B'인 경우
				if (stack1.empty()) {
					return;
				}
				
				stack1.pop();
				return;
			}
		} 
		
		// order.length == 2인 경우
		stack1.push(order[1].charAt(0));
	}
	
	
	private static void workFinish(String str) throws IOException {
		if (!stack2.empty()) {
			finishStack1();
		}

		finishStringBuilder();
	}
	
	private static void finishStack1() {
		int len = stack2.size();
		for (int i = 0; i < len; i++) {
			stack1.push(stack2.pop());
		}
	}
	
	private static void finishStringBuilder() throws IOException {
		for (int i = 0; i < stack1.size(); i++) {
			sb.append(stack1.get(i));
		}
		
		bw.write(sb.toString());
	}
	

}//class



답(else가 있지만 속도는 쬐끔 더 빠른 코드):



import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Stack stack1 = new Stack();
	private static Stack stack2 = new Stack();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = 0;
		String str = "";
		N = inputData(str);
		
		br.close();
	}
	
	public static int inputData(String str) throws IOException {
		str = br.readLine();
		int N = Integer.parseInt(br.readLine());
		inputStack(str);
		
		for (int i = 0; i < N; i++) {
			action(str);
		}
		
		workFinish(str);
		
		return N;
	}
	
	private static void inputStack(String str) {
		for (int i = 0; i < str.length(); i++) {
			stack1.push(str.charAt(i));
		}	
	}
	
	private static void action(String str) throws IOException {
		String[] order = br.readLine().split(" ");

		if (order.length == 1) {
			
			
			if (order[0].charAt(0) == 'L') {
				if (stack1.empty()) {
					return;
				}
				stack2.push(stack1.pop());
			} else if (order[0].charAt(0) == 'D') {
				if (stack2.empty()) {
					return;
				}
				stack1.push(stack2.pop());
			} else if (order[0].charAt(0) == 'B') {
				if (stack1.empty()) {
					return;
				}
				stack1.pop();
			}
		} else if (order.length == 2) {
			stack1.push(order[1].charAt(0));
		}
	}
	
	
	private static void workFinish(String str) {
		if (!stack2.empty()) {
			finishStack1();
		}

		finishStringBuilder();
	}
	
	private static void finishStack1() {
		int len = stack2.size();
		for (int i = 0; i < len; i++) {
			stack1.push(stack2.pop());
		}
	}
	
	private static void finishStringBuilder() {
		for (int i = 0; i < stack1.size(); i++) {
			sb.append(stack1.get(i));
		}
		
		System.out.println(sb.toString());
	}
	

}//class


















################################################################################################################
예제6)알고리즘 기초 1 / 자료구조1 / 큐

*dequeue(덱) 문제가 아니다. queue로만 해겶해라. back을 효율적으로 항상 back할때마다
	조건연산 확인하는것이아니라 특정 값이 바뀌는 곳에서만 연산하도록 헤아려라

https://www.acmicpc.net/problem/10845
################################################################################################################


답:




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static Queue<Integer> que = new LinkedList<>();
	private static int back = -1;
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {			
		int N = Integer.parseInt(br.readLine());
		getData(N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	private static void getData(int N) throws IOException {
		for (int i = 0; i < N; i++) {
			int result = receiveOrder();
			if (result != -2) { // push를 상징하는 수가 반환된 경우 출력하지 말라는 의미
				sb.append(result).append("\n");				
			}
		}
		
		bw.write(sb.toString());
	}

	private static int receiveOrder() throws IOException {
		String[] str = br.readLine().split(" ");

		
		if (str.length == 2) {
			back = Integer.parseInt(str[1]);
			que.offer(back);
			return -2; // push인 경우 출력하지 말라는 의미의 수 반환
		}
		
		{ // str.length == 1 인 경우
			if (str[0].equals("front")) {
				if (que.isEmpty()) {
					return -1;
				}
				
				return que.peek();			
			}

			if (str[0].equals("back")) {
				return back;
			}
			
			if (str[0].equals("pop")) {
				if (que.isEmpty()) {
					return -1;
				}
				
				int tmp = que.poll();
				
				if (que.isEmpty()) {
					back = -1;
				}
				
				return tmp;
			}
			
			if (str[0].equals("size")) {
				return que.size();
			}
			
			if (str[0].equals("empty")) {
				if (que.isEmpty()) {
					return 1;
				}
				
				return 0;
			}
			
		}
		
		return Integer.MAX_VALUE; // 해당 수가 출력될 일은 없음
	}
}//class















################################################################################################################
예제7)알고리즘 기초 1 / 자료구조1 / 조세퍼스 문제

*최대한 효율적이게 해라. 아래 답은 여러가지 방법을 제시한다.
*큐로 풀어라 디큐(덱)금지

https://www.acmicpc.net/problem/1158
################################################################################################################



답:



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Queue<Integer> que = new LinkedList<>();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		int[] N = new int[2];
		N[0] = Integer.parseInt(st.nextToken());
		N[1] = Integer.parseInt(st.nextToken());
				
		inputQueue(N[0]);
		
		sb.append("<");
		makeJosephus(N);
		sb.append(">");
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void inputQueue(int N) {
		for (int i = 1; i <= N; i++) {
			que.offer(i);
		}
	}
	
	public static void makeJosephus(int[] N) {
		while (!que.isEmpty()) { // 실험결과 지금처럼보다는 테두리를 아래 for로 하고 내부 내용물을 넣었을때가 더 빠르네 
			for (int j = 1; j < N[1]; j++) {
				que.offer(que.poll());
			}
			
			sb.append(que.poll()).append(", ");			
		}
//		for (int i = 0; i < N[0]; i++) {
//			for (int j = 0; j < N[1]; j++) {
//				if (j == N[1] - 1) {
//					if (i == N[0] - 1) {
//						sb.append(que.poll());
//						break;
//					}
//					sb.append(que.poll()).append(", ");
//					break;
//				}
//				
//				que.offer(que.poll());
//			}
			
//			int count = 0;
//			while (true) {
//				count++;
//				if (count % N[1] == 0) {
//					if (i == N[0] - 1) {
//						sb.append(que.poll());
//						break;
//					}
//					sb.append(que.poll()).append(", ");
//					break;
//				}
//				que.offer(que.poll());				
//			}
//		}
		
		sb.setLength(sb.length() - 2);
	}
}//class


















################################################################################################################
예제8)알고리즘 기초 1 / 자료구조1 / 덱

https://www.acmicpc.net/problem/10866
################################################################################################################

답:


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Integer> deque = new ArrayDeque<>();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		int N = Integer.parseInt(br.readLine());
		
		getOrder(N);
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static void getOrder(int N) throws IOException {
		for (int i = 0; i < N; i++) {
			int result = runOrder();
			
			if (result != -2) {
				bw.write(String.valueOf(result));
				bw.newLine();
			}
		}
	}
	
	private static int runOrder() throws IOException {
		String[] str = br.readLine().split(" ");
		
		if (str.length == 2) { // que에 입력하는 명령
			if (str[0].equals("push_front")) {
				deque.offerFirst(Integer.parseInt(str[1]));
				return -2;
			}
			if (str[0].equals("push_back")) {
				deque.offerLast(Integer.parseInt(str[1]));
				return -2;
			}
		}
		
		{ // str.length == 1 인 경우
			{ // 삭제 및 출력하는 명령
				if (str[0].equals("pop_front")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.pollFirst();
				}
				if (str[0].equals("pop_back")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.pollLast();
				}				
			}
			{ // 출력민하는 명령
				if (str[0].equals("front")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.peekFirst();
				}
				if (str[0].equals("back")) {
					if (deque.isEmpty()) {
						return -1;
					}
					return deque.peekLast();
				}
			}
			{ // 그밖의 기타 명령
				if (str[0].equals("size")) {
					return deque.size();
				}
				if (str[0].equals("empty")) {
					if (deque.isEmpty()) {
						return 1;
					}
					return 0;
				}
			}
		}
		
		return Integer.MAX_VALUE;
	}
}//class
















































































21.01.03.19회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================





































































	
################################################################################################################
예제9)알고리즘 기초 1 / 자료구조 1 (연습) / 단어 뒤집기 2

*deque를 응용해서 풀어라
	-응용한경우 : 296ms
	-응용 안한경우 : 1708ms

https://www.acmicpc.net/problem/17413
################################################################################################################


답(deque를 효율적으로 이용하여 que와 stack을 동시에 사용하기):
	-단어를 나누지 않음. stack, que 두개를 선언한 다른사람의 방식을 응용한것
	-논리적으로는 단어를 나누는게 더 가독성이 좋지 않나 싶지만 극명한 시간차이.. deque를
		잘 이용하자.. 

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Character> deque = new ArrayDeque<>();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		String str = inputData();
		reverseThrowDeque(str);
		bw.write(sb.toString());
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static String inputData() throws IOException {
		String str = br.readLine();
		return str;
	}

	public static void reverseThrowDeque(String str) {
		str += " ";
		boolean flag = true;
		
		for (int i = 0; i < str.length(); i++) {
			if (str.charAt(i) == '<') {
				if (!deque.isEmpty()) {
					while (!deque.isEmpty()) {
						sb.append(deque.pollLast());
					}
				}
				
				sb.append("<");
				flag = false;
			} else if (str.charAt(i) == '>') {
				while (!deque.isEmpty()) {
					sb.append(deque.pollFirst());
				}
				
				sb.append(">");
				flag = true;
			} else if (str.charAt(i) == ' ') {
				if (flag) {
					while (!deque.isEmpty()) {
						sb.append(deque.pollLast());
					}
				} else {
					while (!deque.isEmpty()) {
						sb.append(deque.pollFirst());
					}
				}
				
				sb.append(" ");	
			} else {
				deque.offerLast(str.charAt(i));
			}
		}
	}
}//class





답(단어와 태그를 먼저 구분한뒤 스택만을 이용하여 출력하는 방식):
	-처음 푼 방법, bunch가 있음. 단어와 태그를 구분한뒤 집어넣어야하니까.

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Character> deque = new ArrayDeque<>();
	private static StringBuilder sb = new StringBuilder();
	private static String[] bunch = new String[100000];
	
	public static void main(String[] args) throws IOException {
		
		String str = inputData();
		int count = cutStr(str);
		reverseThrowDeque(count);
		bw.write(sb.toString());
		
		bw.flush();
		bw.close();
		br.close();
	}
	
	public static String inputData() throws IOException {
		String str = br.readLine();
		return str;
	}
	
	public static int cutStr(String str) {
		int count = 0;
		String tmp = "";

		for (int i = 0; i < str.length(); i++) {
			
			char ch = str.charAt(i);
			if (ch == '<') {
				if (tmp.length() > 0) {
					bunch[count] = tmp;
					count++;
					tmp = "";
				}
				
				while (str.charAt(i) != '>') {
					tmp += str.charAt(i);
					i++;
				}
				tmp += str.charAt(i);
				bunch[count] = tmp;
				count++;
				tmp = "";
				continue;
			}
			
			if (ch == ' ') {
				bunch[count] = tmp;
				count++;
				tmp = "";
				continue;
			}
			
			if (i == str.length() - 1) {
				tmp += str.charAt(i);
				bunch[count] = tmp;
				count++;
				tmp = "";
				continue;
			}
			tmp += str.charAt(i);
		}
		
		return count;
	}
	
	public static void reverseThrowDeque(int count) {
		for (int i = 0; i < count; i++) {
			String tmp = reverseWord(bunch[i]);
			
			if (tmp.charAt(0) == '<') {
				if (sb.length() != 0 && sb.charAt(sb.length() - 1) != '>') {
					sb.setLength(sb.length() - 1);					
				}
				sb.append(tmp);
				continue;
			}
			
			sb.append(tmp).append(' ');
		}
	}
	
	private static String reverseWord(String tmp) {
		if (tmp.charAt(0) == '<') {
			return tmp;
		}
		
		int len = tmp.length();
		for (int i = 0; i < len; i++) {
			deque.offerLast(tmp.charAt(i));
		}
		
		tmp = "";
		for (int i = 0; i < len; i++) {
			tmp += deque.pollLast();
		}
		
		return tmp;
	}
	
}//class




















################################################################################################################
예제10)알고리즘 기초 1 / 자료구조 1 (연습) / 쇠막대기

https://www.acmicpc.net/problem/10799
################################################################################################################


답:



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private static Deque<Character> deque = new ArrayDeque<>();
	private static Stack<Character> stack = new Stack<>();
	private static StringBuilder sb = new StringBuilder();

	private static int separationCount = 0;
	private static int barCount = 0;
	
	public static void main(String[] args) throws IOException {
		String str = inputData();
		inputDeque(str);
		calc();
		lastCalcOfSeparationCount();

		bw.write(String.valueOf(separationCount));
		bw.flush();
		bw.close();
		br.close();
	}

	public static String inputData() throws IOException {
		return br.readLine();
	}
	
//	public static void getTotalCountOfBar() { barCount때매 필요없어진 함수
//		int count = 0;
//		
//		while (!deque.isEmpty()) {
//			int top = deque.pollFirst();
//			
//			if (top == '(' && top == deque.peekFirst()) {
//				count++;
//			}
//		}
//		
//		separationCount = count;
//	}
	
	public static void inputDeque(String str) {
		for (int i = 0; i < str.length(); i++) {
			deque.offerLast(str.charAt(i));
		}
	}
	
	public static void calc() {
		int separationCount = 0;
		
		while (!deque.isEmpty()) {
			char top = deque.pollFirst();
			
			if (top == '('
					&& deque.peekFirst() == ')') { // 레이저인 경우
				int laserCount = 0;
				
				deque.pollFirst();
				laserCount++;
				while ((top = deque.pollFirst()) == '(' 
						&& deque.peekFirst() == ')') {
					deque.pollFirst();
					laserCount++;
				}
				
				deque.offerFirst(top);
				
				checkSeparation(laserCount);
				continue;
			}
			
			{ // top == deque.peekFirst() 레이저가 아닌 경우				
				if (top == '(') { // 쇠막대 하나가 시작된 경우
					stack.push(top);
					barCount++;
					continue;
				}

				if (top == ')'){ // 쇠막대 하나가 끝난 경우
					stack.pop();
					continue;
				}
			}
			
		}
	}
	
	private static void checkSeparation(int laserCount) {
		int exposedCount = stack.size();
		separationCount += exposedCount * laserCount;
	}
	
	private static void lastCalcOfSeparationCount() {
		separationCount += barCount;
	}
}//class














































































21.01.10.20회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================











































































################################################################################################################
예제11)알고리즘 기초 1 / 자료구조 1 (연습) / 오큰수

반례 : 인덱스 전에 것으로 순차적으로 스택의 값의 인덱스가 맞아떨어질거라 생각하면 아래 반례가 나옴
	-그렇기때문에 각 스택의 값에 대한 인덱스를 따로 기록해야함 이걸 클래스를 만들어서(새로운 자료구조) 한다.
6
41 3 2 1 5 4 45

https://www.acmicpc.net/problem/17298
################################################################################################################


답:


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private class Node {
		int index = 0;
		int num = 0;
		
		Node(int index, int num) {
			this.index = index;
			this.num = num;
		}
	}
	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int N;
	private int[] answer;
	private Stack<Node> stack = new Stack<>();
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		input();
		for (int i = 0; i < N; i++) {
			sb.append(answer[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
	
	private void input() throws IOException {
		this.N = Integer.parseInt(br.readLine());
		String[] read = br.readLine().split(" ");
		
		answer = new int[N];
		Arrays.fill(answer, -1);
		
		for (int i = 0; i < N; i++) {
			operateStack(new Node(i, Integer.parseInt(read[i])));
		}
	}
	
	private void operateStack(Node node) {
		while (!stack.isEmpty() && stack.peek().num < node.num) {
			answer[stack.pop().index] = node.num;
		}
		stack.add(node);
	}
}






















################################################################################################################
예제12)알고리즘 기초 1 / 자료구조 1 (연습) / 오등큰수

-3가지 방식이 있는데 가장 빠른 방식으로하라
-아래 답중 가장 아래방식이며 교훈을 읽어라

https://www.acmicpc.net/problem/17299
################################################################################################################



답(다른사람의 빠른 답 참고/입력된 수의 갯수, 입력된 수를 각각의 배열에 넣고 stack에는 
			입력된 값이 들어가는 것이 아니라 인덱스값이 들어감):
	-1128ms

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {
	private static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private static BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private static int[] origin;
	private static int[] count = new int[1000001];
	private static int[] answer;
	private static int N;
	private static Stack<Integer> stack = new Stack<>();
	private static StringBuilder sb = new StringBuilder();
	
	public static void main(String[] args) throws IOException {
		run();
	}
	
	public static void run() throws IOException {
		input();
		compare();
		writeData();
	}
	
	private static void input() throws IOException {
		N = Integer.parseInt(br.readLine());
		origin = new int[N];
		answer = new int[N];
		Arrays.fill(answer, -1);		
		StringTokenizer st = new StringTokenizer(br.readLine());
		
		for (int i = 0; i < N; i++) {
			origin[i] = Integer.parseInt(st.nextToken());
		}
		
		for (int i = 0; i < N; i++) {
			count[origin[i]]++;
		}
	}
	
	private static void compare() {
		stack.push(0);
		
		for (int i = 1; i < N; i++) {
			while (!stack.isEmpty() && count[origin[stack.peek()]] < count[origin[i]]) {
				answer[stack.pop()] = origin[i];
			}
			stack.push(i);
		}
	}
	
	private static void writeData() throws IOException {
		for (int i = 0; i < N; i++) {
			sb.append(answer[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}







답(내가푼 답, 이전 문제에서 응용하여 hash로 값을 찾아냄, stack에 객체를(index, 값, f값 가진 객체) 넣음):
	-1528ms

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private class Node {
		int index = 0;
		int num = 0;
		int f = 0;
		
		Node(int index, int num, int f) {
			this.index = index;
			this.num = num;
			this.f = f;
		}
	}
	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int N;
	private int[] answer;
	private Stack<Node> stack = new Stack<>();
	private StringBuilder sb = new StringBuilder();
	private HashMap<Integer, Integer> hm = new HashMap<>();
	private int[] origin;
	
	public void run() throws IOException {
		input();
		for (int i = 0; i < N; i++) {
			sb.append(answer[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
	
	private void input() throws IOException {
		this.N = Integer.parseInt(br.readLine());
		String[] read = br.readLine().split(" ");
		
		answer = new int[N];
		Arrays.fill(answer, -1);
		
		origin = new int[N];
		for (int i = 0; i < N; i++) {
			origin[i] = Integer.parseInt(read[i]);
		}
		
		for (int i = 0; i < N; i++) {			
			f(i);
		}
		
		for (int i = 0; i < N; i++) {
			operateStack(new Node(i, origin[i], hm.get(origin[i])));
		}
	}
	
	private void f(int i) {
		hm.put(origin[i], hm.getOrDefault(origin[i], 0) + 1);
	}
	
	private void operateStack(Node node) {
		while (!stack.isEmpty() && stack.peek().f < node.f) {
			answer[stack.pop().index] = node.num;
		}
		stack.add(node);
	}
}



답(내가푼 답과 다른이의 답을 합침, 갯수를 배열을 이용하여 값 찾아냄, stack에 객체를(index, 값, f값 가진 객체) 넣음):
	-1092ms
		=> 교훈 : 값들을 각각 배열에 받아서 배열을 응용하는것보다 연결되는 값들은
			클래스로 모아 만든 객체를 이용해서 관리하는 것이 더 빠르다.
package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private class Node {
		int index = 0;
		int num = 0;
		int f = 0;
		
		Node(int index, int num, int f) {
			this.index = index;
			this.num = num;
			this.f = f;
		}
	}
	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private int N;
	private int[] origin;
	private int[] count = new int[1000001];
	private int[] answer;
	private Stack<Node> stack = new Stack<>();
	private StringBuilder sb = new StringBuilder();

	public void run() throws IOException {
		input();
		for (int i = 0; i < N; i++) {
			sb.append(answer[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
	
	private void input() throws IOException {
		this.N = Integer.parseInt(br.readLine());
		String[] read = br.readLine().split(" ");
		
		answer = new int[N];
		Arrays.fill(answer, -1);
		
		origin = new int[N];
		for (int i = 0; i < N; i++) {
			origin[i] = Integer.parseInt(read[i]);
		}
		
		for (int i = 0; i < N; i++) {			
			count[origin[i]]++;
		}
		
		for (int i = 0; i < N; i++) {
			operateStack(new Node(i, origin[i], count[origin[i]]));
		}
	}
	
	private void operateStack(Node node) {
		while (!stack.isEmpty() && stack.peek().f < node.f) {
			answer[stack.pop().index] = node.num;
		}
		stack.add(node);
	}
}



































































































































21.01.11.21회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================





















































































































################################################################################################################
예제13)알고리즘 기초 1 / 자료구조 1 (참고) / 후위 표기식2

https://www.acmicpc.net/problem/1935
################################################################################################################


답(내가 처음 푼 답, hashMap을 이용해서 문자와 해당하는 값을 대응시킴):
	-배열보다 hashMap이 조금 더 빠름
	-128ms


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private HashMap<Character, Integer> hm = new HashMap<>();
//	private Stack<Double> intStack = new Stack<>();
	private Stack<Double> doubleStack = new Stack<>();
	private int N;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {	
		this.N = Integer.parseInt(br.readLine());
		this.str = br.readLine();
		
		for (int i = 0, count = 0; i < str.length(); i++) {
			if (count == N) {
				break;
			}
			
			if (str.charAt(i) < 65 || str.charAt(i) > 90) {
				continue;
			}
			
			if (hm.containsKey(str.charAt(i))) {
				continue;
			}
			
			hm.put(str.charAt(i), Integer.parseInt(br.readLine()));
			count++;
		}
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			
			if (ch >= 65 && ch <= 90) {	
				doubleStack.push((double) hm.get(ch));
				continue;
			}
			
			operateStack(ch);
		}
	}
	
	private void operateStack(char ch) {
		if (ch == '+') {
			double tmp = doubleStack.pop() + doubleStack.pop();
			doubleStack.push(tmp);
			return;
		}
		if (ch == '-') {
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp = o1 - o2;
			doubleStack.push(tmp);
			return;
		}
		if (ch == '*') {
			double tmp = doubleStack.pop() * doubleStack.pop();
			doubleStack.push(tmp);
			return;
		}
		if (ch == '/') {
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp =  o1 / o2;
			doubleStack.push(tmp);
			return;
		}
		{ // ch == '%'
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp =  o1 % o2;
			doubleStack.push(tmp);
		}
	}
	
	private void printData() throws IOException {
		String result = String.format("%.2f", doubleStack.get(0));
		bw.write(result);
		bw.flush();
		bw.close();
		br.close();
	}
}



답(다른사람거 참고, 배열을 이용하여 문자와 해당하는 값을 대응시킴):
	-140ms


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
//	private HashMap<Character, Integer> hm = new HashMap<>();
//	private Stack<Double> intStack = new Stack<>();
	private Stack<Double> doubleStack = new Stack<>();
	private int N;
	private double[] arr;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {	
		this.N = Integer.parseInt(br.readLine());
		this.str = br.readLine();
		arr = new double[N];
		
		for (int i = 0, count = 0; i < str.length(); i++) {
			if (count == N) {
				break;
			}
			
			if (str.charAt(i) < 65 || str.charAt(i) > 90) {
				continue;
			}
			
			
//			if (hm.containsKey(str.charAt(i))) {
//				continue;
//			}
			
			arr[count] = Integer.parseInt(br.readLine()); 
//			hm.put(str.charAt(i), Integer.parseInt(br.readLine()));
			count++;
		}
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			
			if (ch >= 65 && ch <= 90) {	
				doubleStack.push(arr[ch - 'A']);
				continue;
			}
			
			operateStack(ch);
		}
	}
	
	private void operateStack(char ch) {
		if (ch == '+') {
			double tmp = doubleStack.pop() + doubleStack.pop();
			doubleStack.push(tmp);
			return;
		}
		if (ch == '-') {
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp = o1 - o2;
			doubleStack.push(tmp);
			return;
		}
		if (ch == '*') {
			double tmp = doubleStack.pop() * doubleStack.pop();
			doubleStack.push(tmp);
			return;
		}
		if (ch == '/') {
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp =  o1 / o2;
			doubleStack.push(tmp);
			return;
		}
		{ // ch == '%'
			double o2 = doubleStack.pop();
			double o1 = doubleStack.pop();
			double tmp =  o1 % o2;
			doubleStack.push(tmp);
		}
	}
	
	private void printData() throws IOException {
		String result = String.format("%.2f", doubleStack.get(0));
		bw.write(result);
		bw.flush();
		bw.close();
		br.close();
	}
}

























################################################################################################################
예제14)알고리즘 기초 1 / 자료구조 1 (참고) / 후위 표기식

// A + B * C + D
//ABC*+D+
//A + B * (C + D) 
//ABCD+*+
//A+B*C-(D+E)
//ABC*+DE+-
//A+B*(C+D)+(E+F)
//ABCD+EF++*+
//연속된 괄호


https://www.acmicpc.net/problem/1918
################################################################################################################


답:


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private String str;
	private StringBuilder sb = new StringBuilder();
	private Stack<Character> stack = new Stack<>();
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {
		str = br.readLine();
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			
			if (ch >= 65 && ch <= 90) {
				sb.append(ch);
				continue;
			}
			
			if (ch == ')') {
				while (!stack.isEmpty() && stack.peek() != '(') {
					sb.append(stack.pop());
				}
				stack.pop();
				continue;
			}	
			//A + B * C * D
			//ABC*D*+
			{ // ch == (, -, +, *, /인 경우
				while (!stack.isEmpty() && getPriorityScore(ch) != 0 
						&& getPriorityScore(stack.peek()) >= getPriorityScore(ch)) {
					sb.append(stack.pop());
				}
				stack.push(ch);
			}
			
		}
		
		while (!stack.isEmpty()) {
			sb.append(stack.pop());
		}
	}
	
	private int getPriorityScore(char ch) {
		if (ch == '(') {
			return 0;
		}
		
		if (ch == '+' || ch == '-') {
			return 1;
		}
		
		{ // ch == '*' || ch == '/' 의 경우임, ch == ')'인 경우는 해당 메소드로 안들어옴 
			return 2;			
		}
	}
	
	private void printData() throws IOException {
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}






실패한 코드(해당코드는 틀린 코드임):

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class
// A + B * C + D
//ABC*+D+
//A + B * (C + D) 
//ABCD+*+
//A+B*C-(D+E)
//ABC*+DE+-
//A+B*(C+D)+(E+F)
//ABCD+EF++*+
class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

	private Queue<Character> wordQue = new LinkedList<>();
	private Stack<Character> operatorStack = new Stack<>();
	private String str;
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		input();
		calc();
		appendData();
		printData(); 
	}
	
	private void input() throws IOException {	
		str = br.readLine();
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			
			if (ch >= 65 && ch <= 90) {
				runWordStack(ch);
				continue;
			}
			
			if (!operatorStack.isEmpty() && (operatorStack.peek() == '*' 
					|| operatorStack.peek() == '/')) {
				if (ch == '+' || ch == '-') {
					appendData();
					i--;
					continue;
				}
			}
			
			
			
			runOperatorStack(ch);
		}
	}
	
	private void runWordStack(char ch) {
		wordQue.offer(ch);
	}
	
	private void runOperatorStack(char ch) {
		operatorStack.push(ch);
	}
	
	private void appendData() {
		while (!wordQue.isEmpty()) {
			sb.append(wordQue.poll());			
		}
		while (!operatorStack.isEmpty()) {
			if (operatorStack.peek() == ')' 
					|| operatorStack.peek() == '(') {
				operatorStack.pop();
			}
			sb.append(operatorStack.pop());			
		}
	}
	
	private void printData() throws IOException {
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}



































































21.01.13.22회차
===============================================================================
*알고리즘 기초 1 / 2
===============================================================================



































































################################################################################################################
예제15)알고리즘 기초 1 / 자료구조 1 (참고) / 알파벳 개수

https://www.acmicpc.net/problem/10808
################################################################################################################


답:




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private int N;
	private int[] arr = new int[26];
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException{
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {
		str = br.readLine();
		N = str.length();
	}
	
	private void calc() {
		for (int i = 0; i < N; i++) {
			arr[str.charAt(i) - 'a']++;
		}
	}
	
	private void printData() throws IOException {
		for (int i = 0; i < 26; i++) {
			sb.append(arr[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}	






















################################################################################################################
예제16)알고리즘 기초 1 / 자료구조 1 (참고) / 알파벳 찾기

https://www.acmicpc.net/problem/10809
################################################################################################################


답:





package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {	
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private int N;
	private int[] arr = new int[26];
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException{
		input();
		calc();
		printData();
	}
	
	private void input() throws IOException {
		str = br.readLine();
		N = str.length();
		Arrays.fill(arr, -1);
	}
	
	private void calc() {
		for (int i = 0; i < N; i++) {
			if (arr[str.charAt(i) - 'a'] != -1) {
				continue;
			}
			arr[str.charAt(i) - 'a'] = i;
		}
	}
	
	private void printData() throws IOException {
		for (int i = 0; i < 26; i++) {
			sb.append(arr[i] + " ");
		}
		
		bw.write(sb.toString());
		bw.flush();
		bw.close();
		br.close();
	}
}	


















################################################################################################################
예제17)알고리즘 기초 1 / 자료구조 1 (참고) / 문자열 분석

https://www.acmicpc.net/problem/10820
################################################################################################################


답:




package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	private String str;
	private Queue<Node> que = new LinkedList<>();
	
	public void run() throws IOException{
		str = "";
		while ((str = br.readLine()) != null) {
			printData(str);			
		}
		
		bw.close();
		br.close();
	}
	
	private void printData(String nodeStr) throws IOException {
		Node node = new Node();
		node.printData(nodeStr, bw);
	}
}

class Node {
	private StringBuilder sb = new StringBuilder();
	
	private static final int SMALL = 1;
	private static final int BIG = 2;
	private static final int NUM = 3;
	private static final int SPACE = 4;
	
	private int smallCount = 0;
	private int bigCount = 0;
	private int numCount = 0;
	private int spaceCount = 0;
	
	public Node() {
		super();
	}
	private Node(int small, int big, int num, int space) {
		this.smallCount = small;
		this.bigCount = big;
		this.numCount = num;
		this.spaceCount = space;
	}
	
	public void printData(String nodeStr, BufferedWriter bw) throws IOException {
		setData(nodeStr);
		appendData();
		writeData(bw);
	}
	
	private void setData(String nodeStr) {
		for (int i = 0; i < nodeStr.length(); i++) {
			int result = check(nodeStr.charAt(i));
			
			if (result == BIG) {
				this.bigCount++;
				continue;
			}
			
			if (result == SMALL) {
				this.smallCount++;
				continue;
			}
			
			if (result == NUM) {
				this.numCount++;
				continue;
			}
			
			{ // result == SPACE
				this.spaceCount++;
			}
		}
	}
	
	private int check(char ch) {
		if (ch >= 65 && ch <= 90) {
			return BIG;
		}
		
		if (ch >= 97 && ch <= 122) {
			return SMALL;
		}
		
		if (ch >= 48 && ch <= 57) {
			return NUM;
		}
		
		{ // ch == ' ' 
			return SPACE;
		}
	}
	
	private void appendData() {
		sb.append(smallCount + " " + bigCount + " "
				+ numCount + " " + spaceCount + "\n");
	}
	
	private void writeData(BufferedWriter bw) throws IOException {
		bw.write(sb.toString());
		bw.flush();
	}
}













################################################################################################################
예제18)알고리즘 기초 1 / 자료구조 1 (참고) / 단어 길이 재기

이문제는 무슨 의미가 있는지 잘 모르겠다.

https://www.acmicpc.net/problem/2743
################################################################################################################


답:



package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	
	public void run() throws IOException {
		String str = br.readLine();
		System.out.println(str.length());
	}

}









################################################################################################################
예제19)알고리즘 기초 1 / 자료구조 1 (참고) / ROT13(카이사르암호)

*답에는 자료구조측면에서 푸는법 1가지와 수학적측면에서 푸는법 2가지가 있다.
	-수학적측면 방식 2개 차이
		-26개로 되어있으니 주기가 13씩 갔을때 두번가면 다시 처음으로 돌아온다는 것을 이용하여
			간편하게 식 도출
		-직접적으로 넘어간것을 가져와서 맞추는 식으로 식 도출

https://www.acmicpc.net/problem/11655
################################################################################################################


답(내가 자료구조 측면에서 푼 코드):

package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	// 수학적으로 풀지 않고 자료구조 측면에서 푼 답
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private char[] arr; 
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		str = br.readLine();
		arr = str.toCharArray();
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			if (!(ch >= 65 && ch <= 90)
					&& !(ch >= 97 && ch <= 122)) {
				continue;
			}
			
			operateQue(ch, i);
		}
	}
	
	private void operateQue(char ch, int i) {
		Queue<Integer> que = new LinkedList<>();
		setQue(que); // 대소문자 a~z 입력과정
		
		if (ch >= 65 && ch <= 90) {
			fixQue(que, ch, 'A');
			arr[i] = (char) (que.peek() + 'A');
			que.clear();
			return; 
		}
		
		fixQue(que, ch, 'a');
		arr[i] = (char) (que.peek() + 'a');
		que.clear();
	}
		
	private void setQue(Queue<Integer> que) {
		for (int i = 0; i < 26; i++) {
			que.offer(i);
		}
	}
	
	private void fixQue(Queue<Integer> que, char ch, char first) {
		while (que.peek() != ch - first) {
			que.offer(que.poll());
		}			
		
		for (int i = 0; i < 13; i++) {
			que.poll();
		}
	}
	
	private void printData() throws IOException {
		str = String.copyValueOf(arr);
		writeData(str);
	}
	
	private void writeData(String str) throws IOException {
		bw.write(str);
		bw.flush();
		bw.close();
		br.close();
	}
}








답(내가 수학적으로 푼 코드):


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private char[] copyStr;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		str = br.readLine();
		copyStr = str.toCharArray();
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			if (!(ch >= 65 && ch <= 90)   
					&& !(ch >= 97 && ch <= 122)) {
				continue;
			}
			
			if ((ch >= 65 && ch <= 90)
					&& copyStr[i] + 13 > 90) { // 대문자 범위를 넘어서는 경우
				copyStr[i] = (char) (((copyStr[i] + 13) - 90) + 64);
				continue;
			}
			
			if ((ch >= 97 && ch <= 122)
					&& copyStr[i] + 13 > 122) { // 소문자 범위를 넘어서는 경우 
				copyStr[i] = (char) (((copyStr[i] + 13) - 122) + 96);
				continue;
			}
			
			
			{ // 더해도 대문자 및 소문자 범위를 넘어서지 않는 경우				
				copyStr[i] += 13;
			}
		}
	}
	
	private void printData() throws IOException {
		str = String.copyValueOf(copyStr);
		writeData();
	}
	
	private void writeData() throws IOException {
		bw.write(str);
		bw.flush();
		bw.close();
		br.close();
	}
}







답(타인이 수학적으로 푼 답을 응용한 코드):


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private char[] copyStr;
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		str = br.readLine();
		copyStr = str.toCharArray();
	}
	
	private void calc() {
		for (int i = 0; i < str.length(); i++) {
			char ch = str.charAt(i);
			if (!(ch >= 65 && ch <= 90)   
					&& !(ch >= 97 && ch <= 122)) {
				continue;
			}
			
			if ((ch >= 'N' && ch <= 'Z') 
			 		|| (ch >= 'n' && ch <= 'z')){ // 더했을 때 대문자 또는 소문자 범위를 넘어서는 경우
				copyStr[i] -= 13;
				continue;
			}
			
			{ // 더해도 대문자 또는 소문자 범위를 넘어서지 않는 경우				
			  // (ch >= 'A' && ch <= 'M') || (ch >= 'a' && ch <= 'm') 
				copyStr[i] += 13;
			}
		}
	}
	
	private void printData() throws IOException {
		str = String.copyValueOf(copyStr);
		writeData();
	}
	
	private void writeData() throws IOException {
		bw.write(str);
		bw.flush();
		bw.close();
		br.close();
	}
}





















################################################################################################################
예제20)알고리즘 기초 1 / 자료구조 1 (참고) / 네 수


https://www.acmicpc.net/problem/10824
################################################################################################################


답:





package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str1;
	private String str2;
	
	public void run() throws IOException {
		input();
		long result = calc();
		printData(result);
	}

	private void input() throws IOException {
		StringTokenizer st = new StringTokenizer(br.readLine());
		str1 = st.nextToken();
		str1 += st.nextToken();
		str2 = st.nextToken();
		str2 += st.nextToken();
	}
	
	private long calc() {
		long num1 = Long.parseLong(str1);
		long num2 = Long.parseLong(str2);
		
		return num1 + num2;
	}
	
	private void printData(long result) throws IOException {
		bw.write(String.valueOf(result));
		bw.flush();
		bw.close();
		br.close();
	}
}















################################################################################################################
예제21)알고리즘 기초 1 / 자료구조 1 (참고) / 접미사 배열


https://www.acmicpc.net/problem/11656
################################################################################################################


답:


package backjun;

import java.util.*;
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.io.BufferedWriter;
import java.io.OutputStreamWriter;
import java.math.BigInteger;
import java.io.IOException;

public class Main {	
	public static void main(String[] args) throws IOException {
		Solve solve = new Solve();
		solve.run();
	}
}//class

class Solve {
	private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	private BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
	private String str;
	private String[] strArr;
	private StringBuilder sb = new StringBuilder();
	
	public void run() throws IOException {
		input();
		calc();
		printData();
	}

	private void input() throws IOException {
		str = br.readLine();
		strArr = new String[str.length()];
	}
	
	private void calc() {
		makeSub(); // 접미사를 만드는 함수
		Arrays.sort(strArr);
	}
	
	private void makeSub() {
		for (int i = 0; i < str.length(); i++) {
			strArr[i] = str.substring(i);
		}		
	}

	private void printData() throws IOException {
		for (int i = 0; i < strArr.length; i++) {
			sb.append(strArr[i] + "\n");
		}
		writeData();
	}
	
	private void writeData() throws IOException {
		bw.write(sb.toString());			
		bw.flush();
		bw.close();
		br.close();
	}
}